 { type: "string" }
        }
        Method {
            name: "textWidth"
            type: "double"
            Parameter { type: "string" }
        }
        Method {
            name: "textHeight"
            type: "double"
            Parameter { type: "string" }
        }
    }
    Component {
        name: "QQuickTooltip1"
        prototype: "QObject"
        exports: ["QtQuick.Controls.Private/Tooltip 1.0"]
        isCreatable: false
        isSingleton: true
        exportMetaObjectRevisions: [0]
        Method {
            name: "showText"
            Parameter { name: "item"; type: "QQuickItem"; isPointer: true }
            Parameter { name: "pos"; type: "QPointF" }
            Parameter { name: "text"; type: "string" }
        }
        Method { name: "hideText" }
    }
    Component {
        name: "QQuickTreeModelAdaptor1"
        prototype: "QAbstractListModel"
        exports: ["QtQuick.Controls.Private/TreeModelAdaptor 1.0"]
        exportMetaObjectRevisions: [0]
        Property { name: "model"; type: "QAbstractItemModel"; isPointer: true }
        Property { name: "rootIndex"; type: "QModelIndex" }
        Signal {
            name: "modelChanged"
            Parameter { name: "model"; type: "QAbstractItemModel"; isPointer: true }
        }
        Signal {
            name: "expanded"
            Parameter { name: "index"; type: "QModelIndex" }
        }
        Signal {
            name: "collapsed"
            Parameter { name: "index"; type: "QModelIndex" }
        }
        Method {
            name: "expand"
            Parameter { type: "QModelIndex" }
        }
        Method {
            name: "collapse"
            Parameter { type: "QModelIndex" }
        }
        Method {
            name: "setModel"
            Parameter { name: "model"; type: "QAbstractItemModel"; isPointer: true }
        }
        Method {
            name: "mapRowToModelIndex"
            type: "QModelIndex"
            Parameter { name: "row"; type: "int" }
        }
        Method {
            name: "selectionForRowRange"
            type: "QItemSelection"
            Parameter { name: "fromIndex"; type: "QModelIndex" }
            Parameter { name: "toIndex"; type: "QModelIndex" }
        }
        Method {
            name: "isExpanded"
            type: "bool"
            Parameter { type: "QModelIndex" }
        }
    }
    Component {
        name: "QQuickWheelArea1"
        defaultProperty: "data"
        prototype: "QQuickItem"
        exports: ["QtQuick.Controls.Private/WheelArea 1.0"]
        exportMetaObjectRevisions: [0]
        Property { name: "verticalDelta"; type: "double" }
        Property { name: "horizontalDelta"; type: "double" }
        Property { name: "horizontalMinimumValue"; type: "double" }
        Property { name: "horizontalMaximumValue"; type: "double" }
        Property { name: "verticalMinimumValue"; type: "double" }
        Property { name: "verticalMaximumValue"; type: "double" }
        Property { name: "horizontalValue"; type: "double" }
        Property { name: "verticalValue"; type: "double" }
        Property { name: "scrollSpeed"; type: "double" }
        Property { name: "active"; type: "bool" }
        Property { name: "inverted"; type: "bool"; isReadonly: true }
        Signal { name: "verticalWheelMoved" }
        Signal { name: "horizontalWheelMoved" }
    }
    Component {
        prototype: "QQuickWindowQmlImpl"
        name: "QtQuick.Controls/ApplicationWindow 1.0"
        exports: ["QtQuick.Controls/ApplicationWindow 1.0"]
        exportMetaObjectRevisions: [0]
        isComposite: true
        defaultProperty: "data"
        Property { name: "menuBar"; type: "MenuBar_QMLTYPE_4"; isPointer: true }
        Property { name: "toolBar"; type: "QQuickItem"; isPointer: true }
        Property { name: "statusBar"; type: "QQuickItem"; isPointer: true }
        Property { name: "style"; type: "QQmlComponent"; isPointer: true }
        Property { name: "__topBottomMargins"; type: "double" }
        Property { name: "__qwindowsize_max"; type: "double"; isReadonly: true }
        Property { name: "__width"; type: "double" }
        Property { name: "__height"; type: "double" }
        Property { name: "contentItem"; type: "ContentItem_QMLTYPE_2"; isReadonly: true; isPointer: true }
        Property { name: "__style"; type: "QObject"; isReadonly: true; isPointer: true }
        Property { name: "__panel"; type: "QObject"; isReadonly: true; isPointer: true }
        Property { name: "data"; type: "QObject"; isList: true; isReadonly: true }
    }
    Component {
        prototype: "QObject"
        name: "QtQuick.Controls.Styles/ApplicationWindowStyle 1.3"
        exports: ["QtQuick.Controls.Styles/ApplicationWindowStyle 1.3"]
        exportMetaObjectRevisions: [3]
        isComposite: true
        Property {
            name: "control"
            type: "ApplicationWindow_QMLTYPE_14"
            isReadonly: true
            isPointer: true
        }
        Property { name: "background"; type: "QQmlComponent"; isPointer: true }
        Property { name: "panel"; type: "QQmlComponent"; isPointer: true }
    }
    Component {
        prototype: "QQuickFocusScope"
        name: "QtQuick.Controls/BusyIndicator 1.1"
        exports: ["QtQuick.Controls/BusyIndicator 1.1"]
        exportMetaObjectRevisions: [1]
        isComposite: true
        defaultProperty: "data"
        Property { name: "running"; type: "bool" }
        Property { name: "style"; type: "QQmlComponent"; isPointer: true }
        Property { name: "__style"; type: "QObject"; isPointer: true }
        Property { name: "__panel"; type: "QQuickItem"; isPointer: true }
        Property { name: "styleHints"; type: "QVariant" }
        Property { name: "__styleData"; type: "QObject"; isPointer: true }
    }
    Component {
        prototype: "QQuickAbstractStyle1"
        name: "QtQuick.Controls.Styles/BusyIndicatorStyle 1.1"
        exports: ["QtQuick.Controls.Styles/BusyIndicatorStyle 1.1"]
        exportMetaObjectRevisions: [1]
        isComposite: true
        defaultProperty: "data"
        Property { name: "control"; type: "BusyIndicator_QMLTYPE_21"; isReadonly: true; isPointer: true }
        Property { name: "indicator"; type: "QQmlComponent"; isPointer: true }
        Property { name: "panel"; type: "QQmlComponent"; isPointer: true }
    }
    Component {
        prototype: "QQuickFocusScope"
        name: "QtQuick.Controls/Button 1.0"
        exports: ["QtQuick.Controls/Button 1.0"]
        exportMetaObjectRevisions: [0]
        isComposite: true
        defaultProperty: "data"
        Property { name: "isDefault"; type: "bool" }
        Property { name: "menu"; type: "Menu_QMLTYPE_55"; isPointer: true }
        Property { name: "checkable"; type: "bool" }
        Property { name: "checked"; type: "bool" }
        Property { name: "exclusiveGroup"; type: "QQuickExclusiveGroup1"; isPointer: true }
        Property { name: "action"; type: "QQuickAction1"; isPointer: true }
        Property { name: "activeFocusOnPress"; type: "bool" }
        Property { name: "text"; type: "string" }
        Property { name: "tooltip"; type: "string" }
        Property { name: "iconSource"; type: "QUrl" }
        Property { name: "iconName"; type: "string" }
        Property { name: "__position"; type: "string" }
        Property { name: "__iconOverriden"; type: "bool"; isReadonly: true }
        Property { name: "__action"; type: "QQuickAction1"; isPointer: true }
        Property { name: "__iconAction"; type: "QQuickAction1"; isReadonly: true; isPointer: true }
        Property { name: "__behavior"; type: "QVariant" }
        Property { name: "__effectivePressed"; type: "bool" }
        Property { name: "pressed"; type: "bool"; isReadonly: true }
        Property { name: "hovered"; type: "bool"; isReadonly: true }
        Signal { name: "clicked" }
        Method { name: "accessiblePressAction"; type: "QVariant" }
        Property { name: "style"; type: "QQmlComponent"; isPointer: true }
        Property { name: "__style"; type: "QObject"; isPointer: true }
        Property { name: "__panel"; type: "QQuickItem"; isPointer: true }
        Property { name: "styleHints"; type: "QVariant" }
        Property { name: "__styleData"; type: "QObject"; isPointer: true }
    }
    Component {
        prototype: "QQuickAbstractStyle1"
        name: "QtQuick.Controls.Styles/ButtonStyle 1.0"
        exports: ["QtQuick.Controls.Styles/ButtonStyle 1.0"]
        exportMetaObjectRevisions: [0]
        isComposite: true
        defaultProperty: "data"
        Property { name: "control"; type: "Button_QMLTYPE_60"; isReadonly: true; isPointer: true }
        Property { name: "background"; type: "QQmlComponent"; isPointer: true }
        Property { name: "label"; type: "QQmlComponent"; isPointer: true }
        Property { name: "panel"; type: "QQmlComponent"; isPointer: true }
    }
    Component {
        prototype: "QQuickFocusScope"
        name: "QtQuick.Controls/Calendar 1.2"
        exports: ["QtQuick.Controls/Calendar 1.2"]
        exportMetaObjectRevisions: [2]
        isComposite: true
        defaultProperty: "data"
        Property { name: "visibleMonth"; type: "int" }
        Property { name: "visibleYear"; type: "int" }
        Property { name: "frameVisible"; type: "bool" }
        Property { name: "weekNumbersVisible"; type: "bool" }
        Property { name: "navigationBarVisible"; type: "bool" }
        Property { name: "dayOfWeekFormat"; type: "int" }
        Property { name: "locale"; type: "QVariant" }
        Property { name: "__model"; type: "QQuickCalendarModel1"; isPointer: true }
        Property { name: "selectedDate"; type: "QDateTime" }
        Property { name: "minimumDate"; type: "QDateTime" }
        Property { name: "maximumDate"; type: "QDateTime" }
        Property { name: "__locale"; type: "QVariant" }
        Signal {
            name: "hovered"
            Parameter { name: "date"; type: "QDateTime" }
        }
        Signal {
            name: "pressed"
            Parameter { name: "date"; type: "QDateTime" }
        }
        Signal {
            name: "released"
            Parameter { name: "date"; type: "QDateTime" }
        }
        Signal {
            name: "clicked"
            Parameter { name: "date"; type: "QDateTime" }
        }
        Signal {
            name: "doubleClicked"
            Parameter { name: "date"; type: "QDateTime" }
        }
        Signal {
            name: "pressAndHold"
            Parameter { name: "date"; type: "QDateTime" }
        }
        Method { name: "showPreviousMonth"; type: "QVariant" }
        Method { name: "showNextMonth"; type: "QVariant" }
        Method { name: "showPreviousYear"; type: "QVariant" }
        Method { name: "showNextYear"; type: "QVariant" }
        Method { name: "__selectPreviousMonth"; type: "QVariant" }
        Method { name: "__selectNextMonth"; type: "QVariant" }
        Method { name: "__selectPreviousWeek"; type: "QVariant" }
        Method { name: "__selectNextWeek"; type: "QVariant" }
        Method { name: "__selectFirstDayOfMonth"; type: "QVariant" }
        Method { name: "__selectLastDayOfMonth"; type: "QVariant" }
        Method { name: "__selectPreviousDay"; type: "QVariant" }
        Method { name: "__selectNextDay"; type: "QVariant" }
        Property { name: "style"; type: "QQmlComponent"; isPointer: true }
        Property { name: "__style"; type: "QObject"; isPointer: true }
        Property { name: "__panel"; type: "QQuickItem"; isPointer: true }
        Property { name: "styleHints"; type: "QVariant" }
        Property { name: "__styleData"; type: "QObject"; isPointer: true }
    }
    Component {
        prototype: "QQuickFocusScope"
        name: "QtQuick.Controls/Calendar 1.6"
        exports: ["QtQuick.Controls/Calendar 1.6"]
        exportMetaObjectRevisions: [6]
        isComposite: true
        defaultProperty: "data"
        Property { name: "visibleMonth"; type: "int" }
       ]] of perParentApplies) {
    let siblings = []

    for (let [applyCandidate, important, rules] of candidates) {
      let potentialApplyCandidates = [
        applyCandidate,
        ...extractBaseCandidates([applyCandidate], context.tailwindConfig.separator),
      ]

      for (let [meta, node] of rules) {
        let parentClasses = extractClasses(parent)
        let nodeClasses = extractClasses(node)

        // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`
        // So we've split them into groups
        nodeClasses = nodeClasses.groups
          .filter((classList) =>
            classList.some((className) => potentialApplyCandidates.includes(className))
          )
          .flat()

        // Add base utility classes from the @apply node to the list of
        // classes to check whether it intersects and therefore results in a
        // circular dependency or not.
        //
        // E.g.:
        // .foo {
        //   @apply hover:a; // This applies "a" but with a modifier
        // }
        //
        // We only have to do that with base classes of the `node`, not of the `parent`
        // E.g.:
        // .hover\:foo {
        //   @apply bar;
        // }
        // .bar {
        //   @apply foo;
        // }
        //
        // This should not result in a circular dependency because we are
        // just applying `.foo` and the rule above is `.hover\:foo` which is
        // unrelated. However, if we were to apply `hover:foo` then we _did_
        // have to include this one.
        nodeClasses = nodeClasses.concat(
          extractBaseCandidates(nodeClasses, context.tailwindConfig.separator)
        )

        let intersects = parentClasses.some((selector) => nodeClasses.includes(selector))
        if (intersects) {
          throw node.error(
            `You cannot \`@apply\` the \`${applyCandidate}\` utility here because it creates a circular dependency.`
          )
        }

        let root = postcss.root({ nodes: [node.clone()] })

        // Make sure every node in the entire tree points back at the @apply rule that generated it
        root.walk((node) => {
          node.source = atApplySource
        })

        let canRewriteSelector =
          node.type !== 'atrule' || (node.type === 'atrule' && node.name !== 'keyframes')

        if (canRewriteSelector) {
          root.walkRules((rule) => {
            // Let's imagine you have the following structure:
            //
            // .foo {
            //   @apply bar;
            // }
            //
            // @supports (a: b) {
            //   .bar {
            //     color: blue
            //   }
            //
            //   .something-unrelated {}
            // }
            //
            // In this case we want to apply `.bar` but it happens to be in
            // an atrule node. We clone that node instead of the nested one
            // because we still want that @supports rule to be there once we
            // applied everything.
            //
            // However it happens to be that the `.something-unrelated` is
            // also in that same shared @supports atrule. This is not good,
            // and this should not be there. The good part is that this is
            // a clone already and it can be safely removed. The question is
            // how do we know we can remove it. Basically what we can do is
            // match it against the applyCandidate that you want to apply. If
            // it doesn't match the we can safely delete it.
            //
            // If we didn't do this, then the `replaceSelector` function
            // would have replaced this with something that didn't exist and
            // therefore it removed the selector altogether. In this specific
            // case it would result in `{}` instead of `.something-unrelated {}`
            if (!extractClasses(rule).some((candidate) => candidate === applyCandidate)) {
              rule.remove()
              return
            }

            // Strip the important selector from the parent selector if at the beginning
            let importantSelector =
              typeof context.tailwindConfig.important === 'string'
                ? context.tailwindConfig.important
                : null

            // We only want to move the "important" selector if this is a Tailwind-generated utility
            // We do *not* want to do this for user CSS that happens to be structured the same
            let isGenerated = parent.raws.tailwind !== undefined

            let parentSelector =
              isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0
                ? parent.selector.slice(importantSelector.length)
                : parent.selector

            // If the selector becomes empty after replacing the important selector
            // This means that it's the same as the parent selector and we don't want to replace it
            // Otherwise we'll crash
            if (parentSelector === '') {
              parentSelector = parent.selector
            }

            rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate)

            // And then re-add it if it was removed
            if (importantSelector && parentSelector !== parent.selector) {
              rule.selector = applyImportantSelector(rule.selector, importantSelector)
            }

            rule.walkDecls((d) => {
              d.important = meta.important || important
            })

            // Move pseudo elements to the end of the selector (if necessary)
            let selector = parser().astSync(rule.selector)
            selector.each((sel) => movePseudos(sel))
            rule.selector = selector.toString()
          })
        }

        // It could be that the node we were inserted was removed because the class didn't match
        // If that was the *only* rule in the parent, then we have nothing add so we skip it
        if (!root.nodes[0]) {
          continue
        }

        // Insert it
        siblings.push([meta.sort, root.nodes[0]])
      }
    }

    // Inject the rules, sorted, correctly
    let nodes = context.offsets.sort(siblings).map((s) => s[1])

    // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }
    parent.after(nodes)
  }

  for (let apply of applies) {
    // If there are left-over declarations, just remove the @apply
    if (apply.parent.nodes.length > 1) {
      apply.remove()
    } else {
      // The node is empty, drop the full node
      apply.parent.remove()
    }
  }

  // Do it again, in case we have other `@apply` rules
  processApply(root, context, localCache)
}

export default function expandApplyAtRules(context) {
  return (root) => {
    // Build a cache of the user's CSS so we can use it to resolve classes used by @apply
    let localCache = lazyCache(() => buildLocalApplyCache(root, context))

    processApply(root, context, localCache)
  }
}
