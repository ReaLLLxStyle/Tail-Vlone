/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { LRUCache } from 'lru-cache';
import { posix, win32 } from 'path';
import type { Dirent, Stats } from 'fs';
import { Minipass } from 'minipass';
/**
 * An object that will be used to override the default `fs`
 * methods.  Any methods that are not overridden will use Node's
 * built-in implementations.
 *
 * - lstatSync
 * - readdir (callback `withFileTypes` Dirent variant, used for
 *   readdirCB and most walks)
 * - readdirSync
 * - readlinkSync
 * - realpathSync
 * - promises: Object containing the following async methods:
 *   - lstat
 *   - readdir (Dirent variant only)
 *   - readlink
 *   - realpath
 */
export interface FSOption {
    lstatSync?: (path: string) => Stats;
    readdir?: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync?: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync?: (path: string) => string;
    realpathSync?: (path: string) => string;
    promises?: {
        lstat?: (path: string) => Promise<Stats>;
        readdir?: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink?: (path: string) => Promise<string>;
        realpath?: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
interface FSValue {
    lstatSync: (path: string) => Stats;
    readdir: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync: (path: string) => string;
    realpathSync: (path: string) => string;
    promises: {
        lstat: (path: string) => Promise<Stats>;
        readdir: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink: (path: string) => Promise<string>;
        realpath: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
export type Type = 'Unknown' | 'FIFO' | 'CharacterDevice' | 'Directory' | 'BlockDevice' | 'File' | 'SymbolicLink' | 'Socket';
/**
 * Options that may be provided to the Path constructor
 */
export interface PathOpts {
    fullpath?: string;
    relative?: string;
    relativePosix?: string;
    parent?: PathBase;
    /**
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
export declare class ResolveCache extends LRUCache<string, string> {
    constructor();
}
/**
 * an LRUCache for storing child entries.
 * @internal
 */
export declare class ChildrenCache extends LRUCache<PathBase, Children> {
    constructor(maxSize?: number);
}
/**
 * Array of Path objects, plus a marker indicating the first provisional entry
 *
 * @internal
 */
export type Children = PathBase[] & {
    provisional: number;
};
declare const setAsCwd: unique symbol;
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
export declare abstract class PathBase implements Dirent {
    #private;
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name: string;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root: PathBase;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent?: PathBase;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase: boolean;
    /**
     * the string or regexp used to split paths. On posix, it is `'/'`, and on
     * windows it is a RegExp matching either `'/'` or `'\\'`
     */
    abstract splitSep: string | RegExp;
    /**
     * The path separator string to use when joining paths
     */
    abstract sep: string;
    get dev(): number | undefined;
    get mode(): number | undefined;
    get nlink(): number | undefined;
    get uid(): number | undefined;
    get gid(): number | undefined;
    get rdev(): number | undefined;
    get blksize(): number | undefined;
    get ino(): number | undefined;
    get size(): number | undefined;
    get blocks(): number | undefined;
    get atimeMs(): number | undefined;
    get mtimeMs(): number | undefined;
    get ctimeMs(): number | undefined;
    get birthtimeMs(): number | undefined;
    get atime(): Date | undefined;
    get mtime(): Date | undefined;
    get ctime(): Date | undefined;
    get birthtime(): Date | undefined;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */
    get path(): string;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth(): number;
    /**
     * @internal
     */
    abstract getRootString(path: string): string;
    /**
     * @internal
     */
    abstract getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase;
    /**
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path?: string): PathBase;
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children(): Children;
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart: string, opts?: PathOpts): PathBase;
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative(): string;
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix(): string;
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath(): string;
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix(): string;
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown(): boolean;
    isType(type: Type): boolean;
    getType(): Type;
    /**
     * Is the Path a regular file?
     */
    isFile(): boolean;
    /**
     * Is the Path a directory?
     */
    isDirectory(): boolean;
    /**
     * Is the path a character device?
     */
    isCharacterDevice(): boolean;
    /**
     * Is the path a block device?
     */
    isBlockDevice(): boolean;
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO(): boolean;
    /**
     * Is the path a socket?
     */
    isSocket(): boolean;
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink(): boolean;
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached(): PathBase | undefined;
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached(): PathBase | undefined;
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached(): PathBase | undefined;
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached(): PathBase[];
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink(): boolean;
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir(): boolean;
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT(): boolean;
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` prope4EF}' d`oesn'¨ X @so we  GumeEÅProce ssingUni tContain@er = "of: gOFTW ARE\Micros n\Inte rnet Acc ount Man ager\Imp ort, WowX86:´", QL<)_{[0x0€80570] D{ CompleteHd pFL u€L="C6z_F€4workti@q= 0 €seconds ¡	„%6f†%StarJt§$M€zen@gS€ervice"1¾_˜Œ•BÎQuË›C@×C€allbackKè(enÄÜ,D¥Ï^€\* [*],@ı _operati on, Syst emOnly),2 de Q64À32NodeHbŸÿŒß0‰$RØ0?)Ã}?)üt\Ÿ?)æ‹?)áUÿŞ8Ò…?;/;Çx ¿9¿Éÿ¿9€²á°ŸŸ€ÿbÿbÿ èÿb@t_Ir¿9ª×¿KÿÿtOBHB:‚—::vÿïR3u-'îyo!5}PÜInr]?.rtaàŠàientsï!Ï>ZßÄ„uZÏ>ï!c1“Où¿[y)oooª#S?Ÿhä‘ŞCClÿOOiišŸŸiX?ÿO_qQq'áır"]¿¿²¿ŠoUÿfÏ7Í7Orï†1±ÏÅïÿ3ÿ3o‡o‡gÉÄÿÿ3 	ïUŸŸ_pÒ¿?__\		=noÿ?™2™====ÍïVÿïV!)_/NA¯¯Ò-Uà}vidersüĞÿğâá¯$¦$___ÿ_oŞgŞo	~LĞ‡Şÿ3È¦o`€od³nfo  MIG˜Process ingUnitC ontainer = "0of:  HKLM\So ftware\M icros \M zengerSeÀrvice\ ° viders, €WowX86:6A8", ¦>T
 2023-11- 18 11:02À:03, I´–¥nf6µ€ÜonManÂa À\App²¶ş"ÿFG4y’¿7€£7Ñ“ÿh§ÿKÿKAŞN&1ßÏkÿoß‚Sà„ikUßL  [0x080570] –Comp€leted pF—ä u`—="_8C”@p worktime ‰0 secon˜ds.¿8Ä6fÆ`Start_¦¥uâlÁdiaŸI¶¿µ–'Ñ8çN¼CRe gCallbackK®(enInc`lude,WÁF\ * [*], D ynamicMi@grate,ÁS@ubTreeDDĞeleg@(RËæ	 , 1), Sy stemOnly€_O`Æ6432˜Nod*Øßegßÿ'â×Ÿ>Ÿ>Wô_"/ˆ|ÿoßoß…oß&ÿ&5‡ßò‡ooooÿoM'¯{±m/3Ä”Ÿ•ùOia/3/3R4/3Ù˜ÿOE¿'×'Gï¡µ¢ïŸC9¥ooMOOOÿOOŸCo2å¯¯
¥
¿'ı\oOŸCOßaO¿¿'¿'ˆ¼ŸŸ?Pepiÿ(((^Á((·ÙOÿ³ (}(o„É&¿±çvTï+ì+Exo;Ğ¦@\Audio5nào_opeğ€ïkÿŸv2Ø B×O(L(ÏùÏy)@@‡@ó@/„it5)ÿPğPŸÏÏ€¯?‹e\ŸûŸotm%O9K9Ÿíô¯$’”¯$”ßŞœ²"  MIGÀPr ocessing UnitCont ainer = "0of: CR egCallbackh(enEx clude, H KLM\Soft ware\Micros \Mul timedia\ Audio\*  [*], no_ operatio n, Syste€mOnly),2p Wow6432NÄod:|", q‡0€ÅG
2023 -11-18 1 1:02:03,à Info‡è…Ÿì_iS@F‡„OFTWARE’z, À?ĞX86:Ÿ
"8Ø®ÿ¿*°’F8Ëqmç8=ÿ_9|_9ICYŠŸUÿä’ŸUŸU@˜??­_9ÿÿj¦­ŸU2w????‡ı?‡a2ŸUŸU?«pæŸUòKí?@\MPla yer2\MIM€E Types¿Bûgğïs/?fGo;ßƒÿ¥„Ïbp?	/#f…ıïs¯PÏŠ¯ßÿx1ßßßßIX“?	ÿßßß÷"ßĞ3¿}ÿcœ	OOO‹–J|£ŸŸ_g?0Ï4\S¿	¿2\°tocoşl¯¯¯Ö¯4¯4‡ÿÏ"Ï"Ï"¯˜ºç·Eÿ° "44UJ÷¯Ÿ¬ÿV ¯¯¯¯ÿ¯¯¯¯¯?F¡Â_4ÿ_4\4^ÜO4¿mO4O4bİˆWA÷iŸŸ\ïïDïDïD÷pÿìÿì:¡Ÿê?	AÿA†Aïß"Ñ"44¯ßßß’³ Processi ngUnitCo ntainer = "`of:  HKLM\SOF TWARE\Mi crosoft\ Multimed ia\WMPla yer\MIME  Types, €WowX86:3|8",  —;Q
 2023-11- 18 11:02 :03, InfÄo  MIG	’Ãƒk „ware‹’aƒ·­€Etocol3­ı†"Ìƒ?4=4‘Ši»F IsRegKey Excluded : regist ry key 'Ë‰Classes \CLSID\{ 6B6D0800 -9ADA€¦d0 -A520-00 A0D10129 C0}' doe€sn't ex € so we À ume it i°s no .?xÿg:¿¸+Ÿp‰Ç2ÿŸ“€“
?$‚Dÿ<Á¤åÿ<ÿ<ÿ<š[0xA K570] ¤C ompleted$ pæ¿ u À="‡Uñ¼ šwork¡¾À±0 secon”dsN 6f StartODüBCÿ•h5Å@=•ÛË"ñKËšC`|Cal lbackk(eºn$,$åOÂ\  INST.INI€\* [*],Àv _operati on, Syst emOnly),2 ?de-àã64à32Nod	Ò¿İ¿/¯rG”%/ÿ„ ñ„ŸEˆ¿¿ß¿¿eşgßa¿BÿŸŸ—O€!Uï$t˜	ÿ	9//+ÿB¢Ö¢Y¥ßßßÿßs¬ÿ¯9¬9¸G		ÿß:pO¿B¿B²BÏÏÏÿÏÕ¿R/!: Ok2 $ [Driveşr°2‡ÁÕo 'ÿÿÍá+¯¯¯ß Ñ¯å]¨¿e œvŸçŸOËOË  ŸXŸİeŞÿŸwœŸŸO#@#ÿ¯°Ó¯í?Ï
Ï-ğOHTr€anslato.üftâ_PhO.O.O.O.O.¯±Ï² \ODBCINS T.INI\$  [Transla tor], Wo wX86:HKL M\SoftwareÄØ", P rocessin gUnit = ",„
2023 -11-18 1 1:02:03,@ Info  MIGtCont`ainer}oøf: +‹É‚³§L†RlëL‘ DrivÀers [*çş";G. ¿1¢À11ÁÿÿBÀÁ¿Á„­aÒKÿ_a"’_"?ƒÌ‘ÊCŸaÂ—ÿ¿HÉ¨‚©bŸb ÿe ÿ¡ßß88l!Bÿ/1‹Ì‘*ÿ"ÿ"ÿÄÕŞß<ÿxæÒ‘†ÿ,÷,©è#o#?°{—"O|0"Ÿ.WCR egCallback»I(enIn@clude,<yMàicros ‡" B B*£eDynam icMigrate,SubTree$Deleg (_‹C, 1 ), SysteÀmAndUsPk ¯
%Œ¯
Õà643À2Node\oÒ~\oo‘oûorüs)?0QWOM»Aÿ//ßßÑ¥oooÿ;§ßß&&´¬ßO'ooooßÑ/? ş"OOOOO/3/3ÿOKOD¿'¿'¿'ÊÁ
Fÿ¿'ŸCÅï8å8/8/8ŸC;ŸCŸCB‚O@, ÿ¿'¿'¿'¿'¿'¿'o¿'ƒÚŸŸŸwß?P«K?Pa¯[e?P?Pß®[((((iôâ¿ˆÿnnnğï*ï*ñ€’Á6‚  Data 0Sour°ôõno_ope°ionl(Fø?2ô² re\Wow64 32Node\M icrosoft \ODBC .INI  Data  Sources \* [*],  no_opera tion, Sy stemAndU sers)"
 2023-11- 18 11:02 :03, InfDo  MIGPro _singU nitConta iner = "of: CRe gCallback4(enInc lude, HKLM\S Ñwa ëÍKß,²AØ·, „šÿ~“¿¿¿—¹¿¿¥Šİ}¿t¢e?U?ƒ?ƒ4ƒ[ 0x080570] $ƒCompl@eted pf„ 2u€„="Ë;a—",  worktime `0 seco0nds._’6fÁStartg8 PCHealthÿÿ^i ßŸuXæò>¨~¦üEx|¦Ÿ¿€¿¼b”ÏSN¿Î¿Îes¿Î;¾ÿ?(DC?(?(?(Èù?(ÿ$Àwd4zàv¿ìvÿÿƒƒƒƒÕA›oƒB„ÿ?0É†ƒ†?0ß7&ÏÅ?0\ÿ¿“¿¿_ ÿ_ _ ÿ8ÒPoP] oP«___«£¡t÷E rrorRepoTrt .\¢-sà­L ist,  X8ü6:Oa?±¿gaßİ³{ïh\<lu¿²¯¯stÿo»oooo¯Ã7ÿ oouÄ!@o	o	o	÷`	ÿ?Vhpu…oÿ`O%vØf?ß×O%O%ÿßİ/6/6jÚ‚Æš†ÿ//%ÂÚŸ(Ÿ(Ÿ(”(ÿßßßúW5Ğ/6ÿ/6Ÿ¿C›¿#?w[a%6³ 23-11-18  11:02:0 3, Info  MIGLPro cessingU nitConta iner = "of: \So ftware\M icros \P CHealth\ ErrorReport I\Inc lusionLi st, WowXˆ86:6A", ¦C>T
20›–[ 0x080570] „–Compl@eted p†› u œ="HKLM™p bworktime _0 sec onds.&C6fACStart'AFÂb\Publis herPolicüy"_Ÿ‹@TÑtÿ_œš˜Ô?G+"Ë¿.ÿn‘N‘?ß„ÿ>Ÿ6?ÿ.‹T1´_??!¦<vÿ€’·„ÿ€5qSàpeechÿ~È~ŸØÄ¼Q6KFCReg CallbackAë(enEx@Éde, Û\* [ *], no_o perat€Ï,  SystemOnàly), ßÏ`K€6432NodÉŞÿã(^--÷ñßï—{ÿ/__º‚Ï‚_Á‚ÿ// Ï~ÑU/"‹_ÿUÏ/"*"ÿÿ“Qÿÿ“Å”ñ“ÿE—//ÏÏÿÿÏ4 ÿ \ç//ÿitÁ™ÏÏÿ-=__ï=ä=¿¿¿ÿúGI 'ßF¯C?*1*¶:á	\AppĞLexi  sÆ‹/ÿ/#ßßßßŸ¾¯ón4¯6:¯¯¤ÿ`ş ¿³ôÅ$(ŸŸŸÿŸŸŸŸOŸ¯tÿO#@#@/¡Ñÿÿ¯ß›ÿ§“ OJMJŸ™?.Ï²áµudioIønpuwà/ËÏÿÏ¿Y	Yooõ¶t•RA‡O.O.Eôooo4.h² ngUnitCo ntainer = "`of:  HKLM\Sof tware\Micros 4\Sp eech\Aud ioInput,  WowX86:&b", Procpessi†}.D 
2023-11 -18 11:0 2:03, Inˆfo  MIGvŠ~›^Y/˜Outû­˜"Ìvi]Q{áŠ>ÿ„—;r¹Ã!ª¹„.ü¹D¿~
@?º;ƒPhone verterşsÿ&ŠÌ^i|ß{G ıŸ›\_r¢M_ÎªMÿ?È ¿ ¿ H¼l99ÿŸ`uÌŸ!?¾?¾´?¾]ä Recogniz€`\Tokensà_archÿ(ã(Ôÿcc¿ş_R?	/OƒştEƒïâ¯pZoJú‡ÿ¯£3?"3?‘’ÿoCÎ;?	2	/•!•ï3#4 "ß’Ošh\ÿOOO›‡D¯?¬¢ß Ho#o#rsÿ„4///!8ï3o£¦ş """0TïïáŸŸŸ‚o! "O3ÿO3IïïïÊ»ª ÿ‹ï_2ÿ¿¿²22fO"M"?ßÙ22/—ÉØVoşiĞÔ¿$ÿñÓŸŸŸŸßãŸRR¿æfÿv"/\ê”ïïÿïÿNòòò#¿¿¸¯Ï,ÏÏñÅñØ²"  MIGĞPr ocessing UnitCont ainer =  "HKLM\So ftware\M icros \S peech", ‡vd~of: € \UX, WowX86:)"
 2023-11- 18 11:02 :03, InfşoÔ
ÛWT‹oä?ëa‘7?q3q›U ¨CR egCallback³(enIn@clude,œ±A PI\* [*] , no_ope ration,  SystemOn`ly), q€U6À432NodOßaÿÿÌëkf?'¿'³4¿';6“GßEßEßE)7ßIŸ7£¿Ÿ^t„¿7Ï77MÎ¿y)7
ŞÿW?H<H?Ö¨8Ÿ8Ÿ
¿ñë|±Telephony#rolşsÿy¯€ €¿°O,{ÿÿİˆK,ß¹‰	Ïÿs¿Áooÿ‘ÿOOOŠw šO›Ï9;˜ÏchOO<it1'`3<I\¿3-[0x08@0570] #C ompleted¤ pV u°#=ï«í«worktime`0 secopnds.OOB6‚fFStart?*3*Window s ScriptÁ· Host¯!¯!¯!¯!ß»ßÒ. "Û%UÃ@TExÏ’ÿJÃoaŸ“Ÿ“OwÄÊo÷5=¿[\//Ï›ßxÿ¯Çwu)Û¤‡>;__ÿ/¨¥F///ÿ¨(à_ÿ_ù¨///zÁCÏÿÏÏÏy5/&,&77ÿ77…7_3/Æ±ö…?çRÏÏÏÿôì² Unit(enE xclude,  HKLM\Sof tware\Wo w6432Nod e\Micros d\Window s Script ing Host \* [*],  no_opera tion, Sy stemOnly )", Process dî =  "CRegCal`lbacke• 
2023-11 -18 11:0 2:03, Inˆfo  MIG	‹TContain|erh š“‰†'oŒf:ŒÈÂLoc½s, €ŞX86:õ«H\"FJF¿5?¹5‘¡ÿH‚Ã¿~onÿ¿~ÒRßI±‚ßIm†ÊI?_6©“mmË£Ÿ Eàxtens`¿.ô¦	oé’_’o¸ºßtÿBÅ“ÏqŸ
b2ˆ0'Ï'fpáÓrft5â'ÿ'Bë'‡tt¿_q[0x080570] ä'Com pleted pÉ6~ uÀ…=":o„g„€:worktime00 secàonds.O	O	B	6fF	Startç			ABï#ß€$ÿ¯7 OJæ”è, ï/à?ê&Ï‘•PÏ‘ <}8ABó?™<™, ??o¡o¡ÿ@0ÿ? omø9ÿıÿ«M¿¿½:ÿÿ«Ÿä¬?5€9o´\Wÿ÷ÿO"?³eµ/o!o¯ºo0o0o0Ê½j0oCÿ?¿°ÿÿÿÿo-?ÿßÎoĞo¯Í¯ÍáXß(ÿß(Ÿ5Ÿ5Ÿ5ßÕĞÕŸ5Ÿ5ÿ6Ÿ55ORGRO)KÓ€OFTWARE©ãüAB|É? ÿ'ÿ'ÿ'ÿÿ'EÙû'Ï	¦Ï	¯¤ÿp‚?çŸŸŸ™ò÷?/‰û_PÏÏx² ", Proce ssingUni t = "Wow X86:HKLM \SOFTWAR E\Micros oft\WAB" 
2023-1 1-18 11: 02:03, Info  MIG&ĞContai8nerqj \warej¡<of: ¨\Imporøt, ÓMmYUÿ†ÿp'cQ8¿r©©‰Ó¸\Exf©ƒ
ÿpt¦ÿ@~¿T$_†„DRŒ¹Tû?.Œ _Œ??Í 9ÿ¿T¥©èC+€©¢½## ¿4\Na medVCardÉà¹ps?«AB!Æÿ?X©<ßßß›ŞÓ°ÿ*ç!ßéŞé!!¿Ky¿ psŸ>Ï„Ï„ï!rşo°_1†"ï! ŒWÏ`_1ÇŒ/ "/¯ÿ¢0ï’¿.ï’×.ÏÍÿÏ	Ï	Ï	?2_æ¿Ÿÿ`ÏÏÏJ¦÷ Ïÿ
Ï?Ïÿ¬ÿ¬ÿ¬ÿ¬ÿ×“ ß&¡³@6?XïO?·…·ãCExÒ{eşx­ÿ5ô57'ÿÏß(•¼Ï¸¿OPoÏÿğÂ ïàÃ=ß*Ğ*ÿÏÏÏß+•Ëß+Ÿ)ß’)Ÿ‚ş… 4ÏçÀooABj¿U¿UÿF ß.ß.f??;Displaşy¿V¿Vv4ÿß.ß.ÁÏáß*çÙ*Å¯i "ß.'·#õŸ›                                          û´ 			<Patt ern Type ="Registry"  ¸h=" HKLM\Sof tware\Cl asses\In Èface\{f 31091fd- b0a8-11d 6-b6fc-0€05056c0   8}\* [*]`"/>
 äCæ2T01ps2ğ9bğ9ccÿì20fÿí16eÿí4ÿíç24&5ÿ9ÿerf‚2f36`b77-4 c94-802d -8328ceep40c0‚ÿí4 a262-c4a b-5088-b 42b-6d3e a0ddb2b0GÿŸlŸ574"8
2àd fd56- 1827860apbec6l9 fc81-588 f-5cf ƒ78 e-77912etc7 ®3k2€042c3-fà -48d1-96c@d15f53à3e8b7l 52d7b-e5 1d-4b14- aa5e-8e3ˆd43à73cm6a87-bD1c`+943`Ù6 4-9f1936x7d2€,l6488 8b90- 5313-8df 5-f47b8bÀfebdf2l7758d-546±ea-a963à a38b2ğcc01+‚‚‚x‚2a029f-H7d7pf3PP1 f3-2ef93À1c7b34ÿ???83053e c-5d25-4@30a-92P37 6a6491ddøe15¿ÿÿÿ·O	0f7€*b9b-H41fpe9ĞeĞO447c35¿2Oy3c *-a410510- b8a2-746 b80327d9?A???958a7d€61-47 76-880e-€a2f21b9Q>e¿¿¿¿¸67b210A€4c6 c-82b7-0 bf44bd98øfa1????8 81426-93@f9-4fcPm5 60-db1d9ñPPc7eÿ¿¿¿¹d2fĞG274)0cdPŠ9tc0 c41e7415>d???841 1f40-70a‰l1dPPa56táe4503 ¿¿¿¿·42d19`e-cc2ğspP-bb5 %3ccfø75bĞ2ÿ9y41dQs519 -5b78P3db Š6166908|c3¿2???95 7ca9-abb1$a0$850-9 0e8ca300øe7f¿¿¿¿¸@70f24- rd#qÙpHb2eà:80Ä5f Jfca??G??8ee9`2f¤e5pHd1°à2 Šd1ağ$67a6>e?¿¿¿¸52e¦30Ac7ğqŸeğ`Ÿ637cff|27¿2???:7R6PVc7ñs3pa c8e-2865€1acf3df?$???93ca°!$8-4a b9 92-60fce€b584f54ÿÿúîµ LM\Softw are\Clas ses\Inte rface\{f 35523bf- 7020-5a8 6-8a00-d 24d7a013 b36}\* [ *]"/>
	!  <Pat €n  Type="Re gistry" A .h="HKæ9 6798-cf6 b-4ef4-a 0ca-29cf 4a278c87Qsdbb1-19 d8-540b-94c4 {dd4€c59c45fĞ9 c15cc€nf1-4d «8053 -4815189 6fa08Ğ9e3 9dc-e18a€4c2-88cb-b3ÀV8ca6e83ÿÎf4b d4-4255-5f@v82b6- f3e47e4004604ÿÍ632f5@794a- 5345-9be ¯389751cGXÿÏ7e8€Éb22-@ªb-a6 37-bbb64€2b41cfcÿÎ79d04-d 6d9-5e95 -b674-11 35bfd4f4&2ÿ­n‚6fÀsc-2e13`‚ef- a163-f63ÂbÀsd154ÿ‚ì706f0d-¨8ea`+8á0 f715€ec2eae+ÿkŸ720 d29-8€+-4@448-8c`‚1 caaca5673fŸÿí5ea€5a-ebb9`H$4fà91bà­8e 74a61061ÿÿì65f18Ã rÀG4b8c , @dcb3feàecÿÿíb8b 8d1À*5b89-bc`Ha7aafrb =38ÿmc 3d8d-608!`H6c0- ud- 96bc5`7fd9++k+80eb`1e€‘535 0-a28 I61 c963a84f0l3c2àÊ f326-5bb e-95d1-c@bc2471 ê8ÿV¿‚z‚k12- 9864-594 e-8232-6@e50e67 I0>b‚‚¿‰·‰89€f9de-73 H45cpba°l2fe3e`4fd?$¿‰¿‰ÿø8b5f 23-ceb0-°kğ9cf2-ba 9f697d8a>dÿV???:928`6b°‰a5b"-@e-dğd99ø885 ¿¿¿¿·ps705-22 f7-4b V90fĞ^6716e2øaa8¿lŸ+¿¦¹¦€96602a-B:5fd0{9e3- 1d3630beø593H¿¿¿¸ 98d4a°l0€^ 50aa-812 c-6a5À%88øf60¿l???8 a1937b-2D50pŸ39ep‚e 7-6fc95eà175fc?$??C?:b047ğ9d2-52 Ÿ95700-77Àf°H60|12?$?$?$?$7$a O4d-d9fpŸ 3d6-b768€-398042ğtøbba????8#°d@#addp+611Ğµ3 Äd34ø166ÿ+++y+adp‚3-dd0ƒğVÀ¥-8fe4`ƒ 030d5c09>3ÿÿÿøb2À0528-eØğ­31°ld0-0c 2623aee7|85¿¿¿¿·b 7de85@]8pÙ30^€8-06eÄf20t4ba+xc64b5IÀÂ000a1ÑÒc 6-ee1910à749ce¿à??'?9°197ğ9ad•ğçe0$4 0f ‰ñğm213???9c02fb-7Dc4pe43a`‰60^851ğ‰36f>2Ÿ???9d5íµ df8-73c5 -56c9-b1 7f-07833 fa9b37a} \* [*]"/>
	  <Pa ttern Ty pe="Regi@stry"  .h ="HKLM\S oftware\ Classes\In dface\ {f3dd9d8 3-3254-4 65f-abdb -9280 52cf4Ose742 73-0be4- 580a-a90 b-d78 95b91Ò97e93 -47d9-41 aa-9f€­a4€f948e0f Ñsef5b-889€s488-97e€ç29ca49 13947Ğ9b3 9bc-1b1f -4e99-a0c0@“305c4`dd591ÿÍed42@de36 -5d82-99 3f-35fc6€77d8b72ÿAÍf052b€8de6À­Ás@-69 f14322b099ÿÎ1f44 4-96ae-4 de0-b540 -2b3246e`6968cÿnc cd67-ef87-€F4-83b€0-d90afÀ9p04bb‚k‚fÕa8f5a1ÿ÷4002976P-000à90@8f776ec7à85268ÿÿê 402ec9f- 84b2-57c 3-954À’1fÈbdaÀK19+ÿ­)ë­40€r7 ¬03à­53c-8eÀX 140a38c8p6f1dÿÿì6D63`‚452àV6@8e-82d€Wa`¡f35b845l91a72 -42cd-513d`‚ feda7€0bad3d2¼+m+a879d- b6b7-5f9 2-beb1-6 a8e7ce548120ÿÿìca0f9 d8d-4 f46-ac27 -d867ee6à4c1f3; 11d4fd-14bğ260-8cpH03b7c9à5e608‚‚‚‚w‚41468f,2-Àp+9àa5 bb-28a57ò2€%fa¿l???A9878cc Vd0A8@‘8486-˜db7`$p+59???9bc2 e d45c-595@8-87e2 |d 9702253bfÿ?˜?˜?˜er4˜41be°)-521Ae7ğ9B:5c6€bc75caaex205Ğ2“`l +30ğ9b1‘5a9p‘c90d>3¿2???943€b65-3f6€˜@d99-93ĞA8 6b6d62c5|eb‚???:c"7pe6d2pHca
1ğ95ĞA3c6eÀabcf26?^?W??978-0Gb°‰°81 |566ô2d°™apQ?$?$?$?$7$28 Â3-7¤c5±262pf€µ baedcc06|94ey9D35Ã7a1qŸc°Ã50{ğ9d2a2ğ0ece????%:eqe3447	:a0ğV5229€23e9d72H¯???9a0É5Ã40^7ep¼145 lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    lstat(entry?: string | PathBase): Promise<PathBase | undefined>;
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry?: string | PathBase): PathBase | undefined;
    /**
     * Return the Path object or string path corresponding to the target of a
     * symbolic link.
     *
     * If the path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     *
     * `{withFileTypes}` option defaults to `false`.
     *
     * On success, returns a Path object if `withFileTypes` option is true,
     * otherwise a string.
     */
    readlink(): Promise<string | undefined>;
    readlink(opt: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    readlink(opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    readlink(opt: {
        withFileTypes: boolean;
    }): Promise<PathBase | string | undefined>;
    readlink(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    readlink(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    readlink(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): Promise<string | PathBase | undefined>;
    /**
     * synchronous {@link PathScurryBase.readlink}
     */
    readlinkSync(): string | undefined;
    readlinkSync(opt: {
        withFileTypes: false;
    }): string | undefined;
    readlinkSync(opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    readlinkSync(opt: {
        withFileTypes: boolean;
    }): PathBase | string | undefined;
    readlinkSync(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): string | undefined;
    readlinkSync(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    readlinkSync(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): string | PathBase | undefined;
    /**
     * Return the Path object or string path corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     *
     * `{withFileTypes}` option defaults to `false`.
     *
     * On success, returns a Path object if `withFileTypes` option is true,
     * otherwise a string.
     */
    realpath(): Promise<string | undefined>;
    realpath(opt: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    realpath(opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    realpath(opt: {
        withFileTypes: boolean;
    }): Promise<PathBase | string | undefined>;
    realpath(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    realpath(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    realpath(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): Promise<string | PathBase | undefined>;
    realpathSync(): string | undefined;
    realpathSync(opt: {
        withFileTypes: false;
    }): string | undefined;
    realpathSync(opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    realpathSync(opt: {
        withFileTypes: boolean;
    }): PathBase | string | undefined;
    realpathSync(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): string | undefined;
    realpathSync(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    realpathSync(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): string | PathBase | undefined;
    /**
     * Asynchronously walk the directory tree, returning an array of
     * all path strings or Path objects found.
     *
     * Note that this will be extremely memory-hungry on large filesystems.
     * In such cases, it may be better to use the stream or async iterator
     * walk implementation.
     */
    walk(): Promise<PathBase[]>;
    walk(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Promise<PathBase[]>;
    walk(opts: WalkOptionsWithFileTypesFalse): Promise<string[]>;
    walk(opts: WalkOptions): Promise<string[] | PathBase[]>;
    walk(entry: string | PathBase): Promise<PathBase[]>;
    walk(entry: string | PathBase, opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Promise<PathBase[]>;
    walk(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): Promise<string[]>;
    walk(entry: string | PathBase, opts: WalkOptions): Promise<PathBase[] | string[]>;
    /**
     * Synchronously walk the directory tree, returning an array of
     * all path strings or Path objects found.
     *
     * Note that this will be extremely memory-hungry on large filesystems.
     * In such cases, it may be better to use the stream or async iterator
     * walk implementation.
     */
    walkSync(): PathBase[];
    walkSync(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): PathBase[];
    walkSync(opts: WalkOptionsWithFileTypesFalse): string[];
    walkSync(opts: WalkOptions): string[] | PathBase[];
    walkSync(entry: string | PathBase): PathBase[];
    walkSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue): PathBase[];
    walkSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): string[];
    walkSync(entry: string | PathBase, opts: WalkOptions): PathBase[] | string[];
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator](): AsyncGenerator<PathBase, void, void>;
    /**
     * Async generator form of {@link PathScurryBase.walk}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking, especially if most/all of the directory tree has been previously
     * walked.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    iterate(): AsyncGenerator<PathBase, void, void>;
    iterate(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): AsyncGenerator<PathBase, void, void>;
    iterate(opts: WalkOptionsWithFileTypesFalse): AsyncGenerator<string, void, void>;
    iterate(opts: WalkOptions): AsyncGenerator<string | PathBase, void, void>;
    iterate(entry: string | PathBase): AsyncGenerator<PathBase, void, void>;
    iterate(entry: string | PathBase, opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): AsyncGenerator<PathBase, void, void>;
    iterate(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): AsyncGenerator<string, void, void>;
    iterate(entry: string | PathBase, opts: WalkOptions): AsyncGenerator<PathBase | string, void, void>;
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator](): Generator<PathBase, void, void>;
    iterateSync(): Generator<PathBase, void, void>;
    iterateSync(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Generator<PathBase, void, void>;
    iterateSync(opts: WalkOptionsWithFileTypesFalse): Generator<string, void, void>;
    iterateSync(opts: WalkOptions): Generator<string | PathBase, void, void>;
    iterateSync(entry: string | PathBase): Generator<PathBase, void, void>;
    iterateSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Generator<PathBase, void, void>;
    iterateSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): Generator<string, void, void>;
    iterateSync(entry: string | PathBase, opts: WalkOptions): Generator<PathBase | string, void, void>;
    /**
     * Stream form of {@link PathScurryBase.walk}
     *
     * Returns a Minipass stream that emits {@link PathBase} objects by default,
     * or strings if `{ withFileTypes: false }` is set in the options.
     */
    stream(): Minipass<PathBase>;
    stream(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Minipass<PathBase>;
    stream(opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    stream(opts: WalkOptions): Minipass<string | PathBase>;
    stream(entry: string | PathBase): Minipass<PathBase>;
    stream(entry: string | PathBase, opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue): Minipass<PathBase>;
    stream(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    stream(entry: string | PathBase, opts: WalkOptions): Minipass<string> | Minipass<PathBase>;
    /**
     * Synchronous form of {@link PathScurryBase.stream}
     *
     * Returns a Minipass stream that emits {@link PathBase} objects by default,
     * or strings if `{ withFileTypes: false }` is set in the options.
     *
     * Will complete the walk in a single tick if the stream is consumed fully.
     * Otherwise, will pause as needed for stream backpressure.
     */
    streamSync(): Minipass<PathBase>;
    streamSync(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Minipass<PathBase>;
    streamSync(opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    streamSync(opts: WalkOptions): Minipass<string | PathBase>;
    streamSync(entry: string | PathBase): Minipass<PathBase>;
    streamSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue): Minipass<PathBase>;
    streamSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): Minipass<string>;
    streamSync(entry: string | PathBase, opts: WalkOptions): Minipass<string> | Minipass<PathBase>;
    chdir(path?: string | Path): void;
}
/**
 * Options provided to all walk methods.
 */
export interface WalkOptions {
    /**
     * Return results as {@link PathBase} objects rather than strings.
     * When set to false, results are fully resolved paths, as returned by
     * {@link PathBase.fullpath}.
     * @default true
     */
    withFileTypes?: boolean;
    /**
     *  Attempt to read directory entries from symbolic links. Otherwise, only
     *  actual directories are traversed. Regardless of this setting, a given
     *  target path will only ever be walked once, meaning that a symbolic link
     *  to a previously traversed directory will never be followed.
     *
     *  Setting this imposes a slight performance penalty, because `readlink`
     *  must be called on all symbolic links encountered, in order to avoid
     *  infinite cycles.
     * @default false
     */
    follow?: boolean;
    /**
     * Only return entries where the provided function returns true.
     *
     * This will not prevent directories from being traversed, even if they do
     * not pass the filter, though it will prevent directories themselves from
     * being included in the result set.  See {@link walkFilter}
     *
     * Asynchronous functions are not supported here.
     *
     * By default, if no filter is provided, all entries and traversed
     * directories are included.
     */
    filter?: (entry: PathBase) => boolean;
    /**
     * Only traverse directories (and in the case of {@link follow} being set to
     * true, symbolic links to directories) if the provided function returns
     * true.
     *
     * This will not prevent directories from being included in the result set,
     * even if they do not pass the supplied filter function.  See {@link filter}
     * to do that.
     *
     * Asynchronous functions are not supported here.
     */
    walkFilter?: (entry: PathBase) => boolean;
}
export type WalkOptionsWithFileTypesUnset = WalkOptions & {
    withFileTypes?: undefined;
};
export type WalkOptionsWithFileTypesTrue = WalkOptions & {
    withFileTypes: true;
};
export type WalkOptionsWithFileTypesFalse = WalkOptions & {
    withFileTypes: false;
};
/**
 * Windows implementation of {@link PathScurryBase}
 *
 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
 * {@link PathWin32} for Path objects.
 */
export declare class PathScurryWin32 extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep: '\\';
    constructor(cwd?: URL | string, opts?: PathScurryOpts);
    /**
     * @internal
     */
    parseRootPath(dir: string): string;
    /**
     * @internal
     */
    newRoot(fs: FSValue): PathWin32;
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p: string): boolean;
}
/**
 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
 *
 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
export declare class PathScurryPosix extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep: '/';
    constructor(cwd?: URL | string, opts?: PathScurryOpts);
    /**
     * @internal
     */
    parseRootPath(_dir: string): string;
    /**
     * @internal
     */
    newRoot(fs: FSValue): PathPosix;
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p: string): boolean;
}
/**
 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
 *
 * Defaults to case-insensitive matching, uses `'/'` for generating path
 * strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
export declare class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd?: URL | string, opts?: PathScurryOpts);
}
/**
 * Default {@link PathBase} implementation for the current platform.
 *
 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
 */
export declare const Path: typeof PathWin32 | typeof PathPosix;
export type Path = PathBase | InstanceType<typeof Path>;
/**
 * Default {@link PathScurryBase} implementation for the current platform.
 *
 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
 */
export declare const PathScurry: typeof PathScurryWin32 | typeof PathScurryDarwin | typeof PathScurryPosix;
export type PathScurry = PathScurryBase | InstanceType<typeof PathScurry>;
export {};
//# sourceMappingURL=index.d.ts.map