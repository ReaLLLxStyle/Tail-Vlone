"use strict";Object.defineProperty(exports, "__esModule", {value: true});/* eslint max-len: 0 */










var _index = require('../tokenizer/index');
var _keywords = require('../tokenizer/keywords');
var _types = require('../tokenizer/types');
var _base = require('../traverser/base');













var _expression = require('../traverser/expression');








var _statement = require('../traverser/statement');









var _util = require('../traverser/util');

function isMaybeDefaultImport(lookahead) {
  return (
    (lookahead.type === _types.TokenType.name || !!(lookahead.type & _types.TokenType.IS_KEYWORD)) &&
    lookahead.contextualKeyword !== _keywords.ContextualKeyword._from
  );
}

function flowParseTypeInitialiser(tok) {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, tok || _types.TokenType.colon);
  flowParseType();
  _index.popTypeContext.call(void 0, oldIsType);
}

function flowParsePredicate() {
  _util.expect.call(void 0, _types.TokenType.modulo);
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._checks);
  if (_index.eat.call(void 0, _types.TokenType.parenL)) {
    _expression.parseExpression.call(void 0, );
    _util.expect.call(void 0, _types.TokenType.parenR);
  }
}

function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.colon);
  if (_index.match.call(void 0, _types.TokenType.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (_index.match.call(void 0, _types.TokenType.modulo)) {
      flowParsePredicate();
    }
  }
  _index.popTypeContext.call(void 0, oldIsType);
}

function flowParseDeclareClass() {
  _index.next.call(void 0, );
  flowParseInterfaceish(/* isClass */ true);
}

function flowParseDeclareFunction() {
  _index.next.call(void 0, );
  _expression.parseIdentifier.call(void 0, );

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  _util.expect.call(void 0, _types.TokenType.parenL);
  flowParseFunctionTypeParams();
  _util.expect.call(void 0, _types.TokenType.parenR);

  flowParseTypeAndPredicateInitialiser();

  _util.semicolon.call(void 0, );
}

function flowParseDeclare() {
  if (_index.match.call(void 0, _types.TokenType._class)) {
    flowParseDeclareClass();
  } else if (_index.match.call(void 0, _types.TokenType._function)) {
    flowParseDeclareFunction();
  } else if (_index.match.call(void 0, _types.TokenType._var)) {
    flowParseDeclareVariable();
  } else if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._module)) {
    if (_index.eat.call(void 0, _types.TokenType.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (_index.match.call(void 0, _types.TokenType._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    _util.unexpected.call(void 0, );
  }
}

function flowParseDeclareVariable() {
  _index.next.call(void 0, );
  flowParseTypeAnnotatableIdentifier();
  _util.semicolon.call(void 0, );
}

function flowParseDeclareModule() {
  if (_index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0, );
  } else {
    _expression.parseIdentifier.call(void 0, );
  }

  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_index.match.call(void 0, _types.TokenType._import)) {
      _index.next.call(void 0, );
      _statement.parseImport.call(void 0, );
    } else {
      _util.unexpected.call(void 0, );
    }
  }
  _util.expect.call(void 0, _types.TokenType.braceR);
}

function flowParseDeclareExportDeclaration() {
  _util.expect.call(void 0, _types.TokenType._export);

  if (_index.eat.call(void 0, _types.TokenType._default)) {
    if (_index.match.call(void 0, _types.TokenType._function) || _index.match.call(void 0, _types.TokenType._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      _util.semicolon.call(void 0, );
    }
  } else if (
    _index.match.call(void 0, _types.TokenType._var) || // declare export var ...
    _index.match.call(void 0, _types.TokenType._function) || // declare export function ...
    _index.match.call(void 0, _types.TokenType._class) || // declare export class ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) // declare export opaque ..
  ) {
    flowParseDeclare();
  } else if (
    _index.match.call(void 0, _types.TokenType.star) || // declare export * from ''
    _index.match.call(void 0, _types.TokenType.braceL) || // declare export {} ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._interface) || // declare export interface ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) || // declare export type ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) // declare export opaque type ...
  ) {
    _statement.parseExport.call(void 0, );
  } else {
    _util.unexpected.call(void 0, );
  }
}

function flowParseDeclareModuleExports() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._exports);
  flowParseTypeAnnotation();
  _util.semicolon.call(void 0, );
}

function flowParseDeclareTypeAlias() {
  _index.next.call(void 0, );
  flowParseTypeAlias();
}

function flowParseDeclareOpaqueType() {
  _index.next.call(void 0, );
  flowParseOpaqueType(true);
}

function flowParseDeclareInterface() {
  _index.next.call(void 0, );
  flowParseInterfaceish();
}

// Interfaces

function flowParseInterfaceish(isClass = false) {
  flowParseRestrictedIdentifier();

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && _index.eat.call(void 0, _types.TokenType.comma));
  }

  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._mixins)) {
    _index.next.call(void 0, );
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }

  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
    _index.next.call(void 0, );
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }

  flowParseObjectType(isClass, false, isClass);
}

function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseInterface() {
  flowParseInterfaceish();
}

function flowParseRestrictedIdentifier() {
  _expression.parseIdentifier.call(void 0, );
}

function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  flowParseTypeInitialiser(_types.TokenType.eq);
  _util.semicolon.call(void 0, );
}

function flowParseOpaqueType(declare) {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
  flowParseRestrictedIdentifier();

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  // Parse the supertype
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeInitialiser(_types.TokenType.colon);
  }

  if (!declare) {
    flowParseTypeInitialiser(_types.TokenType.eq);
  }
  _util.semicolon.call(void 0, );
}

function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();

  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    flowParseType();
  }
}

 function flowParseTypeParameterDeclaration() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  // istanbul ignore else: this condition is already checked at all call sites
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.typeParameterStart)) {
    _index.next.call(void 0, );
  } else {
    _util.unexpected.call(void 0, );
  }

  do {
    flowParseTypeParameter();
    if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  } while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error);
  _util.expect.call(void 0, _types.TokenType.greaterThan);
  _index.popTypeContext.call(void 0, oldIsType);
} exports.flowParseTypeParameterDeclaration = flowParseTypeParameterDeclaration;

function flowParseTypeParameterInstantiation() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.lessThan);
  while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {
    flowParseType();
    if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
  _util.expect.call(void 0, _types.TokenType.greaterThan);
  _index.popTypeContext.call(void 0, oldIsType);
}

function flowParseInterfaceType() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._interface);
  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }
  flowParseObjectType(false, false, false);
}

function flowParseObjectPropertyKey() {
  if (_index.match.call(void 0, _types.TokenType.num) || _index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0, );
  } else {
    _expression.parseIdentifier.call(void 0, );
  }
}

function flowParseObjectTypeIndexer() {
  // Note: bracketL has already been consumed
  if (_index.lookaheadType.call(void 0, ) === _types.TokenType.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  _util.expect.call(void 0, _types.TokenType.bracketR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeInternalSlot() {
  // Note: both bracketL have already been consumed
  flowParseObjectPropertyKey();
  _util.expect.call(void 0, _types.TokenType.bracketR);
  _util.expect.call(void 0, _types.TokenType.bracketR);
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    _index.eat.call(void 0, _types.TokenType.question);
    flowParseTypeInitialiser();
  }
}

function flowParseObjectTypeMethodish() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  _util.expect.call(void 0, _types.TokenType.parenL);
  while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {
    flowParseFunctionTypeParam();
    if (!_index.match.call(void 0, _types.TokenType.parenR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }

  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
  _util.expect.call(void 0, _types.TokenType.parenR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}

function flowParseObjectType(allowStatic, allowExact, allowProto) {
  let endDelim;
  if (allowExact && _index.match.call(void 0, _types.TokenType.braceBarL)) {
    _util.expect.call(void 0, _types.TokenType.braceBarL);
    endDelim = _types.TokenType.braceBarR;
  } else {
    _util.expect.call(void 0, _types.TokenType.braceL);
    endDelim = _types.TokenType.braceR;
  }

  while (!_index.match.call(void 0, endDelim) && !_base.state.error) {
    if (allowProto && _util.isContextual.call(void 0, _keywords.ContextualKeyword._proto)) {
      const lookahead = _index.lookaheadType.call(void 0, );
      if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
        _index.next.call(void 0, );
        allowStatic = false;
      }
    }
    if (allowStatic && _util.isContextual.call(void 0, _keywords.ContextualKeyword._static)) {
      const lookahead = _index.lookaheadType.call(void 0, );
      if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
        _index.next.call(void 0, );
      }
    }

    flowParseVariance();

    if (_index.eat.call(void 0, _types.TokenType.bracketL)) {
      if (_index.eat.call(void 0, _types.TokenType.bracketL)) {
        flowParseObjectTypeInternalSlot();
      } else {
        flowParseObjectTypeIndexer();
      }
    } else if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._get) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._set)) {
        const lookahead = _index.lookaheadType.call(void 0, );
        if (lookahead === _types.TokenType.name || lookahead === _types.TokenType.string || lookahead === _types.TokenType.num) {
          _index.next.call(void 0, );
        }
      }

      flowParseObjectTypeProperty();
    }

    flowObjectTypeSemicolon();
  }

  _util.expect.call(void 0, endDelim);
}

function flowParseObjectTypeProperty() {
  if (_index.match.call(void 0, _types.TokenType.ellipsis)) {
    _util.expect.call(void 0, _types.TokenType.ellipsis);
    if (!_index.eat.call(void 0, _types.TokenType.comma)) {
      _index.eat.call(void 0, _types.TokenType.semi);
    }
    // Explicit inexact object syntax.
    if (_index.match.call(void 0, _types.TokenType.braceR)) {
      return;
    }
    flowParseType();
  } else {
    flowParseObjectPropertyKey();
    if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {
      // This is a method property
      flowParseObjectTypeMethodish();
    } else {
      _index.eat.call(void 0, _types.TokenType.question);
      flowParseTypeInitialiser();
    }
  }
}

function flowObjectTypeSemicolon() {
  if (!_index.eat.call(void 0, _types.TokenType.semi) && !_index.eat.call(void 0, _types.TokenType.comma) && !_index.match.call(void 0, _types.TokenType.braceR) && !_index.match.call(void 0, _types.TokenType.braceBarR)) {
    _util.unexpected.call(void 0, );
  }
}

function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    _expression.parseIdentifier.call(void 0, );
  }
  while (_index.eat.call(void 0, _types.TokenType.dot)) {
    _expression.parseIdentifier.call(void 0, );
  }
}

function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseTypeofType() {
  _util.expect.call(void 0, _types.TokenType._typeof);
  flowParsePrimaryType();
}

function flowParseTupleType() {
  _util.expect.call(void 0, _types.TokenType.bracketL);
  // We allow trailing commas
  while (_base.state.pos < _base.input.length && !_index.match.call(void 0, _types.TokenType.bracketR)) {
    flowParseType();
    if (_index.match.call(void 0, _types.TokenType.bracketR)) {
      break;
    }
    _util.expect.call(void 0, _types.TokenType.comma);
  }
  _util.expect.call(void 0, _types.TokenType.bracketR);
}

function flowParseFunctionTypeParam() {
  const lookahead = _index.lookaheadType.call(void 0, );
  if (lookahead === _types.TokenType.colon || lookahead === _types.TokenType.question) {
    _expression.parseIdentifier.call(void 0, );
    _index.eat.call(void 0, _types.TokenType.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}

function flowParseFunctionTypeParams() {
  while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {
    flowParseFunctionTypeParam();
    if (!_index.match.call(void 0, _types.TokenType.parenR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
}

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
  let isGroupedType = false;
  const oldNoAnonFunctionType = _base.state.noAnonFunctionType;

  switch (_base.state.type) {
    case _types.TokenType.name: {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
        flowParseInterfaceType();
        return;
      }
      _expression.parseIdentifier.call(void 0, );
      flowParseGenericType();
      return;
    }

    case _types.TokenType.braceL:
      flowParseObjectType(false, false, false);
      return;

    case _types.TokenType.braceBarL:
      flowParseObjectType(false, true, false);
      return;

    case _types.TokenType.bracketL:
      flowParseTupleType();
      return;

    case _types.TokenType.lessThan:
      flowParseTypeParameterDeclaration();
      _util.expect.call(void 0, _types.TokenType.parenL);
      flowParseFunctionTypeParams();
      _util.expect.call(void 0, _types.TokenType.parenR);
      _util.expect.call(void 0, _types.TokenType.arrow);
      flowParseType();
      return;

    case _types.TokenType.parenL:
      _index.next.call(void 0, );

      // Check to see if this is actually a grouped type
      if (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis)) {
        if (_index.match.call(void 0, _types.TokenType.name)) {
          const token = _index.lookaheadType.call(void 0, );
          isGroupedType = token !== _types.TokenType.question && token !== _types.TokenType.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        _base.state.noAnonFunctionType = false;
        flowParseType();
        _base.state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (
          _base.state.noAnonFunctionType ||
          !(_index.match.call(void 0, _types.TokenType.comma) || (_index.match.call(void 0, _types.TokenType.parenR) && _index.lookaheadType.call(void 0, ) === _types.TokenType.arrow))
        ) {
          _util.expect.call(void 0, _types.TokenType.parenR);
          return;
        } else {
          // Eat a comma if there is one
          _index.eat.call(void 0, _types.TokenType.comma);
        }
      }

      flowParseFunctionTypeParams();

      _util.expect.call(void 0, _types.TokenType.parenR);
      _util.expect.call(void 0, _types.TokenType.arrow);
      flowParseType();
      return;

    case _types.TokenType.minus:
      _index.next.call(void 0, );
      _expression.parseLiteral.call(void 0, );
      return;

    case _types.TokenType.string:
    case _types.TokenType.num:
    case _types.TokenType._true:
    case _types.TokenType._false:
    case _types.TokenType._null:
    case _types.TokenType._this:
    case _types.TokenType._void:
    case _types.TokenType.star:
      _index.next.call(void 0, );
      return;

    default:
      if (_base.state.type === _types.TokenType._typeof) {
        flowParseTypeofType();
        return;
      } else if (_base.state.type & _types.TokenType.IS_KEYWORD) {
        _index.next.call(void 0, );
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
        return;
      }
  }

  _util.unexpected.call(void 0, );
}

function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!_util.canInsertSemicolon.call(void 0, ) && (_index.match.call(void 0, _types.TokenType.bracketL) || _index.match.call(void 0, _types.TokenType.questionDot))) {
    _index.eat.call(void 0, _types.TokenType.questionDot);
    _util.expect.call(void 0, _types.TokenType.bracketL);
    if (_index.eat.call(void 0, _types.TokenType.bracketR)) {
      // Array type
    } else {
      // Indexed access type
      flowParseType();
      _util.expect.call(void 0, _types.TokenType.bracketR);
    }
  }
}

function flowParsePrefixType() {
  if (_index.eat.call(void 0, _types.TokenType.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}

function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!_base.state.noAnonFunctionType && _index.eat.call(void 0, _types.TokenType.arrow)) {
    flowParseType();
  }
}

function flowParseIntersectionType() {
  _index.eat.call(void 0, _types.TokenType.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while (_index.eat.call(void 0, _types.TokenType.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}

function flowParseUnionType() {
  _index.eat.call(void 0, _types.TokenType.bitwiseOR);
  flowParseIntersectionType();
  while (_index.eat.call(void 0, _types.TokenType.bitwiseOR)) {
    flowParseIntersectionType();
  }
}

function flowParseType() {
  flowParseUnionType();
}

 function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
} exports.flowParseTypeAnnotation = flowParseTypeAnnotation;

function flowParseTypeAnnotatableIdentifier() {
  _expression.parseIdentifier.call(void 0, );
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
}

 function flowParseVariance() {
  if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {
    _index.next.call(void 0, );
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
  }
} exports.flowParseVariance = flowParseVariance;

// ==================================
// Overrides
// ==================================

 function flowParseFunctionBodyAndFinish(funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }

  _expression.parseFunctionBody.call(void 0, false, funcContextId);
} exports.flowParseFunctionBodyAndFinish = flowParseFunctionBodyAndFinish;

 function flowParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (_index.match.call(void 0, _types.TokenType.questionDot) && _index.lookaheadType.call(void 0, ) === _types.TokenType.lessThan) {
    if (noCalls) {
      stopState.stop = true;
      return;
    }
    _index.next.call(void 0, );
    flowParseTypeParameterInstantiation();
    _util.expect.call(void 0, _types.TokenType.parenL);
    _expression.parseCallExpressionArguments.call(void 0, );
    return;
  } else if (!noCalls && _index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    flowParseTypeParameterInstantiation();
    _util.expect.call(void 0, _types.TokenType.parenL);
    _expression.parseCallExpressionArguments.call(void 0, );
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  }
  _expression.baseParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
} exports.flowParseSubscript = flowParseSubscript;

 function flowStartParseNewArguments() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    flowParseTypeParameterInstantiation();
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
  }
} exports.flowStartParseNewArguments = flowStartParseNewArguments;

// interfaces
 function flowTryParseStatement() {
  if (_index.match.call(void 0, _types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._interface) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    _index.next.call(void 0, );
    flowParseInterface();
    _index.popTypeContext.call(void 0, oldIsType);
    return true;Ü£Ê‰ﬁ†kä~˘¥iàÀÏæ‘ î◊@Ù":úÜÎ-¨è©=ùÓ+	ØF“ú ≠©›WÆ»gäGÿ¿Ñ ¿ÏÇVõs`¥bÇ	\kóY∂Ê!¶›;’è,Ò¿N7ﬁ7$E∂òDOƒ¸ÊFZhH≥”t≤_Oå•,\“kÃ≈ve8˚ß9]zôi˘;êKà«!¿˘3âT¯6+9A”∞’içï-fC#”ho«	Piˆ.:˙Jx÷Ç¢¥=q2µ≥X∑	BqêÊ–3<Ú˛KÿÌÊ≈(5`¡µø∞˘rB¡D¶…wÕ∆»y◊;ƒHû wâ-+ﬁÓﬁ√”ˆ˛2ÀW=Û>˚Í±Õ8_"t9E¥2Ù˚Ú*Û≠^è	í ¸ †~@+ı<˚2ÿ/0Ç|£$<¬¢6‘n”®•ŸpTLQYµóﬁñ¥pgGŒÿ⁄≈°Ø¢ïÀ¢ò:
˝Ü≥ÿíNRwìŸΩî´áµKRÁôÜ»…OÜî8SsÑ3Ê¸j¥wá£PÏÔÑ¬„
bÂkn±¥·ÛjñÅDh‡ö˝›?_lûÂÉ"ô&h©)§sQKcy>Œ¿™/
Û%¥ò!Ÿ·∆<œ>NÓ-'«-/ì0˝üπe„›„Ω$•5ŸSiÆÅ±„NÑT#ÓäÇ\)‚±◊(míÑSæ≥Q¯æ¢ ó¶„úı)B¿@á ‰ãÂúUñçòxÜ[^Ë∞hD–SJËÁÚ
Õ+mÂ*eZj€5ˆë–T˜%Ì:ôZUvÁJ`_¶ﬁ˜ü-ÉIzR•t^üò——©q´ÑÑ“&+ÑÛÛøü
l√—Õé–»$vë®˙_X”˙ò¥¡âU}aA‚Ïjj:XÜü¸>•ƒ≥ıÚj™ö‘~x"„”ªŸÜM¡íI±u∞ÄT‚Œ¡sPrÎ[Â‘ÇS‹bâkºK_<ßïYÿt/¸¡\;õªÑ◊CVÁ„ærı≥∑oYÑÃÒp†‡è ◊ıí-µJ≈◊ª"äpûe∫ÖA‘¥h˛ßi3j≠æ/:}Ïv·y‹⁄ÒÜ±√õüÕﬁÈõSÖ©ÀÅf9xºÔhî∑*	cÑ[TçŒ@É˝\q“&µ3¡ífõ9ˆ´±œ Ëı¡whÚ9ﬂÍƒÁ ˛\€(K¯NÊPÏ¡&ø	/*+≈v¢ä≥±~ò∞§0çvÀÊB•<Ü∂ÑGnLVi'Ûèπ√YG∂~XåÛæ›&.˙9±éáàÈ.\, Ñtwq"¡%D„Ω∏≤í_‹˚€kÆá©äÂÂõ&oLuF+]u–óY?U≠±¨ï´Œ∞†ÚgTâŒ∂∫BuÄÙóö¯µÒP@Fpg€◊XàÖÅf^›0”a2ÏM`c
›ÿ˝R≠∞Ì~
%Í70v§2;÷˝â‚§úsMCïÈ∞Øºy‡º„ªÄ’1'm$w>◊•Ò%Ã~^é=ﬂ£ŸµøJ]∞h€⁄π iœS˜vù?⁄oUú’¡‡Z*ÏéUA‹ !&{ú^Â§?¨ı˘öTfÜ,Ï{qÌ∫Ú´L~∂‡é‚„¢8>s;L¸ ª‘ñ…Û	pø`∂…X∑40ƒ7û“∏é¯°‡ÀK*ÌVñ47s!¥Èπlp}Ö™”Æ&ÄJ®ì–˛í◊ÿæ–H¡2æ∫Ô≤o¶(àû5t∆/d‰[Ç"!Ì¬ôEõR∏üÃ¸(!˜/ü?ØlÖŒ˚±"ª≈MíJMwjI¨Ÿ˚ƒª˜√N∂°8;E∂)y|w.“wá(®˜–π€QGc•ﬂ(ü ëüe∂3b´îG¶T®ÄΩÈ1√Êöb¯ﬁ&û>H‰;]våû¸MÂ%[ôË∂;Ä•˛3òç›5≤úôt˘i:9€5ˆÕÑ>2u¶&•äó°ÓõòqŒΩÛÜxÕ›j>‡DKÂ®Ïè∂°î\ÊKm§ª¡Ω I \,ïtŸ¨$$,ïÅn(uÚt4uWl‹4R# ˇ
õ|Í÷¬ä·Ô ËI$•a,√V£ækR˝GJ]or¨
;ü–®+~∫vòΩ	p¨'ú•„"’£”¬WÎà≥´*∏≠–U™UÚÀ@cÆ{‹Jœ∞!a√…•â‹CG´'üÚ§+ª∆ªú·IG™Ó*vQ°ÎCüúµ?wG–;∫/äﬁ˜AOø?´ﬁŒBõá`≈nÌë›Î5Ñéˆº\j¸Ë–&¸aús Á›˜D5ê!´˘òcPtœ∑Ω‡MÃÉ—D3≥&√lÆ$´UÅ84Á{4?}˘£◊–˚nxÓ¥∏øo‘∂´Æ…yAÙ"ÿr∞ÿ¶πdèî˜”ï†”!√Oy ûäùq%@ÕÃ)‰4≠æ%•ù≠…H§HlàﬂjH›zï9ˆ	≠±“˘a·≈ÿës»a;to5ôÍÖy\¥=¬+GÑÄç4üZçf©Ôœ≤7.µQ†jB¬DJ€ÕGG/¨,Vï´¬/∫\¯√zô˙ÄBï[@CÎ∏a® ¸Úæi€Ñ⁄D∞V∂~2‚•s=Ó5¢[pmuHBf9©‹>±ˇP_,<P|T3ã'QûyœXç—æsè€€ù)å≥?‘ë˜sæBÆ«ú–?% ™»õÆú@…Á¥båZhÜR;€‹ﬂ÷ìÒ∑Xq
£Ω£‚h˛$I„dD'xO›o‰2ù"∞ ˆQhuO◊ÎjsAsJ•Ó^áK•p%∞‹Lë{ΩK¬§!È:<É,ÇJ5òµ I--s ∆@$É¬}´*û™†Z˜`eπÃ˘??¡m‹Qéï9r}nhó	≥åH‹"p }™œ°6ﬁÍ’¿ı’\å(©„ÛaqCLÍﬁ≥ŸònP≥rûD¡ùS)ˇyøΩvˇ˛Ù≠ˆJeâ∞T~ÕóÀïµà Oæp	¬∫îÃ*é=‘»¶;˘CÃVnÔê©›”Ls#c
6Û√Xä,A®¡[£kp<Rﬁ˙ÛÇC[îPjÓ©ÈÔ©¬ù¶¸AM∂´f›Ïa‹ˇdGïùTo5t5Q˙ ∞z†ÍKUE≈+’∆Ó&ÅÊ|@–˚+ô˘^, b˘ÙªTT^kÃ*±NÄÀ∞' ª+¢9|ÃÓaM§1¯^÷»¸b`∏€¸?¢Õ;È/d/¯∫oú
3ã!Ts5nIhÒÃ=¶£à<‹àü¬ˇ&ôŒÁÄ¶‚˘ç∆$eY∞æè`Rö Ç°ñﬁ>6·ΩF:npëAA≤ Uo bEÙÎ•»≥)Äc˙î35 ÅœS®â˘ˇsÒæÅ˚.ﬁX∂tR}»”ß®>Úw£‚‰€º›ç0u}~IAdiÔ'{Ñ6ùVñbÉVÂ„.#ÃÑwFÕBòìæNMV⁄˙Æ“Cx›<E
÷oQn}l˛3[CRáQ⁄b›tƒ,}∞R*™˙R!7ª•F–äaõài•¥n⁄qOì("Â.ˇr\ONõ˘∏hÕ>≠XåC
Xë¶Ú7mÅµ+¨H˝Ö¨;[˛¥Eÿú$G7∆	iD√≈c!]£]±¨1WAfó'@˚ Ì˘ò;r≥ÛE˚Á†ﬂgÉ¢trëU†OˇzNÆhÃYÖﬂåDj£≠¥e™Ñê,Ÿ vIB11õˆ æ∂HûWˆôâ
”±rÙ Im‰€òA7GàÇ<÷î1YMÄÿíº“ª*¢<Ûvõ®„:‘aÌ-ÓÖõÆ[åÖQv⁄≈˛"}¿jöi©¶a!Î¯bàÆÁ%&¥p+	”3M¸ |Y §Q≠h◊a3}¬Ag·R◊ÉE&Z·…>çá¸M5ˆÌÚÙ ∑`qzóW¿.	i I˘‚ÉÎï˜]èƒß>Øs≈ﬁÆ«à#ZyΩà´ôE-i≠Ÿèßdù≈œÚvK»∞π@S©_&Ò2≤uí¡»'˘0ÆÈA	LÔº—ß@`,¶n=–7'ØÛ¢Á‘í‚dËÃÌ;+ˆAoÒh›uH&Ï}÷åÙ{8zJaÊœÅ√∑ÊˆÙlâ]{ÀºD˝’p¢`"˜hKkïÂŸ>Ω>Y|z5±—ÍÜ´?Päz6g:pûÏ>€∫§3¿BπDB6√‰™~ïcãu≠K(–Hˇ∆{W∂BxÙ?‡ÿ˚zâÈk§~dg›ª8pÇf‡QEÎ‚jìáH'eL“Î‡ÓÊﬂû Jœﬁã(C≥Î∫Ø0˚8ﬂw˛Q”ˇÈ¯0“ç©∆)w(÷Ã<'v)Ô"m˝©VK8H‡óÄ'`≤$¡#ﬁxÓÒJ1 Í°-lÀ2DKüÕ6´Xc f#›î§¡’Qª2!°ÕJ*«ôF+s‡uÂy=ºñ◊-FYJnd"29»ì∞4&ävst‚LõÍ&¡â@v(Èw#ÎgK~ˇz»†xuÄ‡[≈›≈âæ@FÍÁã
=@ê≤Éõ≠÷ÃVè€pP*É!UÌÇM¡&˙økâ,Àˇ©èΩy¶:ƒ%íö¨®3|çÍÑvU´ìf§2«‘†xU˚uU"KËŒ™ï√î÷‰µR«†æma;œ:;yƒ7É`F'=Åø‹òàª‘ˆ‹â0ùJ5ÑΩı Ï”xDiR…4ë˜Xò„‘öVÚPÕ’ÂÓ°üÔesA8"©§5?'ãÇE¿¬ZSˇ”µÖ‹ +]·jÁ(
≠Ÿ4óûr°√®ã¶8sŸπıQÀÔ5tØ÷!RŸKπW}á
ã±zºûQZsâ§„êágkmØ‚*ÏJ.\∆◊…Ë*4UÕ0j&jH˙(Æ_JπÑì1ˇ§∂!p–òÂ¬ÓÄê|∞éÊ˜#t6VJ1”%cﬁU—ÜÛP@KÕ_	πÓ”»a1**≈5˙Ãç«(£=ê—!ÕgH;ì(ƒÖ5—6∫R‹cÎœŒÄ“-Ö¯3ÿí"Éâ*åM{≥¸B/Ó”ˇjùIáx≈¨˙xU'=≥ïS”P´!c≈ÆØπI Ä:™O^$ô~êπΩ'Ñå‘—lSv<*î?u# –Ó¸ÕT¨(~aéQ⁄»hSf@OŸiå∑sRw∫		kY	P∂ó®1e˛ﬁ¨^º_=•3∏‹x∂n»(Q#	sQ[Nı;)¸?7$˛MÇîIl•Ì≠“J2—,TëõÜ£íc8’¶ˇü¡uthVπB…¯ÛØøGr¶ˇ=eô˝ Œô›™7g◊{≥ç9ë¿ ;ÅÄ»ØÌ˜UÜf˛_&À?ËﬂÔô≠ÒÙÆë,~;MòœgPkï{&28È˜Fˇ∑ô‰ﬁº:Á¬âQÙ6$†Û]D±Á¿b/ˇ≤äU
‚c—qRyb„˘ËÛ˜}∑B’9©îmüS≈≥iR∑–ºq…iCßÉHõ‰g8¯æÄ!:∂ñö9Yjà)És
/kïå.Ph«06ùA7ú	Q7Épn“p(jç≤àæ6∫]≠~ZÚB»/PÎ1f&(Dªç„r¥Ó≠•‹Íût_¿√øz$È/¿ŸΩÇ÷]á>≠‰€D‰#ÀÌÔƒ)e,±Ää∂ÑŸa.Ü!ÉÃ…–{Ì’¶:5NÒKäk∞¨8ÄzüsOñµ¿X±ä/•°í[¶=%ëT€oÕ\2_πÍ¸§’úUcå<_tBÊá«∫üq%≤ï+ö)†ã}ØÜj8ÅÒ*	Ë9Ú—ÄÀÛ®cÍ ⁄QDt∞+RdIe‡5”ˆ [PBµ∫ÿê"ƒ,l°àÕ+ GΩ«¡K–WÛ‚ómΩ”nCõÎoB•ÖÏk†G+} √Ö<∏æÍŒ¡–›≤ÜGÔ§øåéµ2^ú¥;˜^]eË|bYaÙø∑*8°á¯Œ=¯¶ós‡Öå~ O;*àÉVÏ—ËºF–˛ ŸYÜY¯Jà»05,ß≥Ë”B#"„y,ë≤9Ó‡2A‡R≈LP 0¶˝i\°âPX8PﬁZÎΩ◊ÑgDÀÑo˜bÉ¯sIN≈˝V<ﬂ…j\‚µé"°T_´^D.Ú˚	¶ëáZwõ  Hcìß]ïmO[·∑BÓhˆÊÓ&√œé’¶+ñ^[jﬂ Ëjy+12ï√Æç÷Yˆ÷|4 GÍ?rkÆ√z<e¸•Ç9ÆÇrîkÊ˜}/xú`T@Ï¬7¨£º§∂Ã	¨õ„3|∏lèœú‰¬˘0Çám,apÊë$+ıﬁfe∑]“∂éàù.ïüFâÉ—∫Àﬁ©@&Æ"˛B ™◊1˘¶:ëU	Ò®(…∑ˆ„3ô∏…∏é°#x*ÁN Ê√¯8\FPo+ û˘∑?W≥Øm€Œ±wÜ-K|äÃ—ﬁı≠ÊΩ¿¬ér.ééxØªA÷oÂq∆b(Ì;1ı…Àh∏ ,s•ÕÇ#áy_—§1úbPykF^)™„o∏—≥rM˝µCﬁõ∫-¡£ÚÂÆgÔ“K	˙èüÌËi@d7¸vÂAA W ødG
ˇh Á>ì¢bdßÅâ"}´Ms≠Oê”ˆXZ… ¨A∞c^Ò®"'ŒÄ`’Ù–Ïã»x∞™ª≠5O…ï–˜<˙He»[Ω†bIF«z_‘’!Ë«ñ≠x°¢¸™&êG™7ù§ÿfs—&NOsë;≠¢6‡Ù‘ÏTˇß§ad3`b˘∆%€§6øwÖ0#âb0Ãs›¥à)πoDÍ–kôΩ=Ãt	íwµ%¢Ãº*z≈=ä3$Rœıu≠vŒÎ√¿µ¿ùçÃç„ùK?∂EÿCÊex√?‡Å⁄ıÓ=f%MGãıÛ„Ñ6˙=Î 9€ ŒñÌW’¸0+S∫ÁlÄVdL n†^mAw*‘q÷
æ@•9}yâ≠‰À¬xóóV‹Â ¨Óp~ÛÚeUéË`]èM«CAΩ¿M/*˝Ÿu◊¢¯Æ6ÅÑT	áÎÆ†á…@°m‰ıJ∞ÁÏ≈˛s I„ª8´R[ørØ\qÃ˘ZI”ÊY,$¬µ≠©É∆]À»bÍGr¯}˙¡áw.ï¬√tÛ–ZËO≥LVÖ~∞Øên2∑q8ò¸v	≥ﬂ⁄6ÇD1∑¥4êﬁ¡Õ©Îáq¿}Ω.≠ƒa¯z:epì«#©∫”FaBºQÉíäF∏iÅEaßË˚úÖ‡t48D*¨kQaãl∫±Ü:∂˜PYéC5˝"H’õ p⁄aç|1óée¥Ûâ©æTéîÆ}j-]ÿÖ *€2•a¥¬)çK.=ª3ﬂ®P∏√>@!ˆ)R˜÷Xˇ≥
ñémÂÍûzÚÎHñﬁÜ»kÁ-aÎÁÔ÷ÙºX∫t<dî’πx—úÙ%˜∏6®ãùsâ"Dí¶‘Rù†L
R9ô≠¨aì√´ÆKÑ,)™¥'F“<Y∑‡cÎ`Ì“ØúÈ3;Y —q–($∏)U≠h¬ì(0ï‚¸ö6ÁQ+1ˇò{‰ué/>úì5¯6ñ∆áa"GR˙ûøbÂRhoøI¡˝):rﬁ=∫∆!OÒcA<sïıØ≈˝tajÂ%…‹÷\(lw‹§Këä©Öz√»:ëátœŒem–£Kï Ÿƒ˛3Pf9,%∑Lª≥6DI/∞ﬂæÊ± ©>‚’	H\ûFı•∆∫ìŸÈn¢ ¡¶±P•RÔ≤YæÌUí+7à°;Ùl◊'}öÒ€OrõÒ>¡|·hÄ£—ô√O€„0é§∑èÑ´»5õ	‘0¿›_geãtk)∏ñ∂QÆ)ª‡…1û¥åo@Uˇ≈íPZ±hÿ÷˙œRiDP√≠*P“¡v.óZû…]—%ËAÌ<·èΩUOl÷ÈYR1ZíŒ†!A…ÕaØMÀ¯V˝≠uv3V/©⁄¯YüÕZ·DÂ%0KÏ
∫É“≈™a‹fã≠ £@éÉ»SZ√3#9D4X,ÙâËÊåºg&u!RPﬂmÑo¥ˆ¸‚P(ûOP»sˇk#mÒ⁄Ñ˜ÏÂU∫∑<BÙtÈ,ú≈±€k{5Œ&Ã`Ò˙«+fE∑ƒAôßÂﬂX¬∆Kå®A{sˇæEÄÉ>Û\_'ñ=’</Ï¡uàÚÜ¯ã¨Ö°y"<COQ˙‚\⁄x§˜ÒÏ±‘ØwòUA(I>Ó◊“:Á¿A∫÷ ©|«ËYm∂◊\î®ÉXV0üœ-VU∞Çu%“≈yàÑØ¯t_Zëm`.T6∏Üˇ‚Ä„{ßxá◊∏‚˝TÇ¶†Ã0Ùâd¯#»≠<≥EB2üîq¯s´lDIaÄÓqíÔ~Ì3y]R˛Œ/Z?= ^X9˘ﬂw‚$w7ã∏~,Î√ØF˘ånàb∆ëÛ€ıÛÚY˘≈¡•7¨ÆØIıÖ≤*7ˇõQÚÂnó‹Sm’ÍTjSDyÕÑ¯πci~ıs±[Õ2K¿∑·5∫˜Å_xı¿˛eCƒJ%˜	˝æ’Æ'*n≥÷ŒO68-©˛
G¬]1T&
åz∆pûxÁ"!˛˝å ‰EgOÌ2∂I{¡Ω; ˆHp⁄"˛ã%±NéªeqÜÜ¨)%h2Bïhñ±Êò[∑peƒ˚‡
í“ns?GqRo∆9˝˜”à»Y¬Ï Ω·._∑’…Ÿ—I†tâ≥q\°∏¸úÃ??Jâ∑Kx”÷?∫y*ä¶k—ÏD≠[‡YzV
«>"®∫6µ2kÇÈ}E-iÌo'!∫´˛uh-¶∞≤1œDl∞t+F˛>F˙æÙ}Eqˇ,ãä¡∞dä˘ﬁ$wò˙«/
Áèmä|ë0›ˇ¡r≠ÖN∞5íGy\-’Ô∑Bw¶uƒ†e}bt÷„cæùÃjÆÛ≠!…$/H+§ùõ∫-∫Ñúmˇ™ùKyÄ}ùô‰áF´j¢∞7úä˘øÑê6e]Pj˙À-5˝É6”‡ÓágLoi\‹ñ^4e+ÕôE~Aﬁƒ\a…^"-)∑.ﬂ†J˚[ß”-„:›¢ÿØÀ;–…≥ÛøÏt√ÜP¯#˛|‚ﬁﬁŒ‚Â√VÕq¶€[Î¡ç˘t¸U÷qwXCÆ?kçâ-ª˜KQÌj•HY†~unH†ˇîLôE˜$ôQd#/õÌCILâ›é∂{[N	àŸXXê
˚<p=Gígﬂ^◊…z⁄1UŸµÓSV(mûM√,g^9c·‡◊È»EÔjAZ‰]±ZΩÀ·fÃ8Àˆö4;¸§]9œK\À€uQŒ¬oí»zGLBc˘Â+⁄öâ6:ü˛ÅZ¢l]3πB<Wüa.`[∫1q+<ÀòˇïÄ†<&®#0A&»‹Û0;íõÓ-ôrÃ¢éˇG+—Ú;ø…Jì68+Bæ}Ò:ª«±ô!<ãy∫ÜlÚî wrΩÛås‘k¡ˇ6t∂JÄ∂V8üEÄÆnÜÜ‡Ä€$<ïªÈÓ`{ˇ`ëÊ"Æß©•°dÕ!Ú¬3YÑ“ØÚ¬oˇñÃA¡"ÛWÃÉ¯à≤¬ï·™±‘F˝põMüF*ê+Å√gêè	ç+Åäˇ©Íù‘n òQÃtMÆ&„L}Ü
–Õ%˙£gr™_O∂¯Ì>…ŸüπP8dæŒ•ñè°ª§‰‰èj>¬≤Äv@4jÍ<∑ø#Jâ>w‡DJ9z°wo˚3—Ô'ÑÇˆp˛(L£©T]À§HVF„Á˘ﬂ˜∂Sﬂxb¢º∞„±m‚£aîª‡¢`Íƒâó¯Úíh’uÑBÊ©Ò'¸V|Bñˇ13^⁄Nåï⁄tÅê∆£U˛áË~ç1F∫Ô·˘≥ﬂÈi7 (¡&˛◊¨_®æıâ0¶,Ÿ…å˜-“YË7‹TXÃ[WêùL«KA;‘;(YÔΩΩ9Ó´”¯ÂAÒ§Ä›ò`Gßo|Ïï–b]ª,ƒ±,ïŸVMÍã]öï—i°¯Ú|úoã3†¬»ÿﬂ(´¡ñ 		ÙÔUCXÔ~2ÊÆÇµ¨\E»§¿I°˚ DZn¶ „lw⁄‰ºñ˜±u°=‰‚∑GÔpé4ã
AgÃo}PvßÈk\3j$0Ò˝á}TÜâr¸„√å¨Æd‚u—è¬´ëc
±,Ö…±ºÎå\hwﬂuw:ÓÛ±y≤Ä©„f˚ ·÷”Zhƒó÷=∂ß*E⁄ˆHV˚Àv¸∆[ﬁ›ÀA–ê3Ûä˜eLì®V¿¬ns7À⁄9
Ì Äö}!o±¨ÄsÄ’Ú\è›ÓÃÀ6Í(\9<‹¥©ËSÛ¨4ûÊ¨PÕæ‚:”¡Ü'óF®ÃwØu˜óŒ(Ç @›…
)3ìµËDèeS,Ôò·:åÔ∫Ò∑ó|û)áv¬µ=xıù^∫ìÕÎDnöÒ∑ÂävÜ˚¸®¸u∂89≈ÏèC˛C‰™VÕ¯n“õ°üKÍVÄdÈ6/–≤Wv¯<†QÀ1ëèòÖ•a „øÇ“ÓoE≤Cw˜˜jÎe.£ëM˜mÎ…M⁄ö⁄wØ+XÆT[mË˚zËØPIºÇÔÌ±e‹Ó0∂|OL‰7[iXÃCa∫yHØ˛rdù3Ÿ“Ùö¬ï9ç 3»<[8Uá»ZET‘‰;Ä\ÆAdqÂ”UAI◊|¯!÷6≠vzåÜÂ‰ R‹;?˛ÔvOŸç„ünB¸Ü…<õm°äÈêÿÂªÌÂ¢(*4Y-/Ø3ûywm†‡à’L=Q!s0ÜæK*W{«X[úQ¡‹ ,ô$–Œùÿ∏!æõ‘öª¥nXkL´â∑ø.ctr3	Ñ/™©±˛˝ÂÀ©Huuπu√Ã∫∂í´[D˘ˆ.#|û∞xªK|˙ê·ç∫VSéé≥ã
1˙é?=Ûë@çF¥AªÒˆ9i<Éü∏|{,	ØÎ\:EpÃK
!√ã¶d€ÕbM0Óöd(Õv§Í4ù:™µ˘Së÷˙ÜClk7t‹„§Ä‰Xœ5aÓµ…¬Wô—ÒÈ[l}
  }
} exports.flowParseImportSpecifier = flowParseImportSpecifier;

// parse function type parameters - function foo<T>() {}
 function flowStartParseFunctionParams() {
  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon
  // anyway, so don't try to propagate that information.
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    flowParseTypeParameterDeclaration();
    _index.popTypeContext.call(void 0, oldIsType);
  }
} exports.flowStartParseFunctionParams = flowStartParseFunctionParams;

// parse flow type annotations on variable declarator heads - let foo: string = bar
 function flowAfterParseVarHead() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
} exports.flowAfterParseVarHead = flowAfterParseVarHead;

// parse the return type of an async arrow function - let foo = (async (): number => {});
 function flowStartParseAsyncArrowFromCallExpression() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    _base.state.noAnonFunctionType = true;
    flowParseTypeAnnotation();
    _base.state.noAnonFunctionType = oldNoAnonFunctionType;
  }
} exports.flowStartParseAsyncArrowFromCallExpression = flowStartParseAsyncArrowFromCallExpression;

// We need to support type parameter declarations for arrow functions. This
// is tricky. There are three situations we need to handle
//
// 1. This is either JSX or an arrow function. We'll try JSX first. If that
//    fails, we'll try an arrow function. If that fails, we'll throw the JSX
//    error.
// 2. This is an arrow function. We'll parse the type parameter declaration,
//    parse the rest, make sure the rest is an arrow function, and go from
//    there
// 3. This is neither. Just call the super method
 function flowParseMaybeAssign(noIn, isWithinParens) {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    let wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
      _base.state.type = _types.TokenType.typeParameterStart;
    } else {
      return wasArrow;
    }

    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    flowParseTypeParameterDeclaration();
    _index.popTypeContext.call(void 0, oldIsType);
    wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
    if (wasArrow) {
      return true;
    }
    _util.unexpected.call(void 0, );
  }

  return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
} exports.flowParseMaybeAssign = flowParseMaybeAssign;

// handle return types for arrow functions
 function flowParseArrow() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    const snapshot = _base.state.snapshot();

    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    _base.state.noAnonFunctionType = true;
    flowParseTypeAndPredicateInitialiser();
    _base.state.noAnonFunctionType = oldNoAnonFunctionType;

    if (_util.canInsertSemicolon.call(void 0, )) _util.unexpected.call(void 0, );
    if (!_index.match.call(void 0, _types.TokenType.arrow)) _util.unexpected.call(void 0, );

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
    _index.popTypeContext.call(void 0, oldIsType);
  }
  return _index.eat.call(void 0, _types.TokenType.arrow);
} exports.flowParseArrow = flowParseArrow;

 function flowParseSubscripts(startTokenIndex, noCalls = false) {
  if (
    _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async &&
    _index.match.call(void 0, _types.TokenType.lessThan)
  ) {
    const snapshot = _base.state.snapshot();
    const wasArrow = parseAsyncArrowWithTypeParameters();
    if (wasArrow && !_base.state.error) {
      return;
    }
    _base.state.restoreFromSnapshot(snapshot);
  }

  _expression.baseParseSubscripts.call(void 0, startTokenIndex, noCalls);
} exports.flowParseSubscripts = flowParseSubscripts;

// Returns true if there was an arrow function here.
function parseAsyncArrowWithTypeParameters() {
  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  _statement.parseFunctionParams.call(void 0, );
  if (!_expression.parseArrow.call(void 0, )) {
    return false;
  }
  _expression.parseArrowExpression.call(void 0, startTokenIndex);
  return true;
}

function flowParseEnumDeclaration() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
  _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
  _expression.parseIdentifier.call(void 0, );
  flowParseEnumBody();
}

function flowParseEnumBody() {
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._of)) {
    _index.next.call(void 0, );
  }
  _util.expect.call(void 0, _types.TokenType.braceL);
  flowParseEnumMembers();
  _util.expect.call(void 0, _types.TokenType.braceR);
}

function flowParseEnumMembers() {
  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
      break;
    }
    flowParseEnumMember();
    if (!_index.match.call(void 0, _types.TokenType.braceR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
}

function flowParseEnumMember() {
  _expression.parseIdentifier.call(void 0, );
  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    // Flow enum values are always just one token (a string, number, or boolean literal).
    _index.next.call(void 0, );
  }
}
