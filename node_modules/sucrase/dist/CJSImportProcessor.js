"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _tokenizer = require('./parser/tokenizer');
var _keywords = require('./parser/tokenizer/keywords');
var _types = require('./parser/tokenizer/types');

var _getImportExportSpecifierInfo = require('./util/getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);
var _getNonTypeIdentifiers = require('./util/getNonTypeIdentifiers');
















/**
 * Class responsible for preprocessing and bookkeeping import and export declarations within the
 * file.
 *
 * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and
 * interopRequireWildcard, so we also allow that mode for compatibility.
 */
 class CJSImportProcessor {
   __init() {this.nonTypeIdentifiers = new Set()}
   __init2() {this.importInfoByPath = new Map()}
   __init3() {this.importsToReplace = new Map()}
   __init4() {this.identifierReplacements = new Map()}
   __init5() {this.exportBindingsByLocalName = new Map()}

  constructor(
     nameManager,
     tokens,
     enableLegacyTypeScriptModuleInterop,
     options,
     isTypeScriptTransformEnabled,
     keepUnusedImports,
     helperManager,
  ) {;this.nameManager = nameManager;this.tokens = tokens;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.options = options;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.keepUnusedImports = keepUnusedImports;this.helperManager = helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this);}

  preprocessTokens() {
    for (let i = 0; i < this.tokens.tokens.length; i++) {
      if (
        this.tokens.matches1AtIndex(i, _types.TokenType._import) &&
        !this.tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)
      ) {
        this.preprocessImportAtIndex(i);
      }
      if (
        this.tokens.matches1AtIndex(i, _types.TokenType._export) &&
        !this.tokens.matches2AtIndex(i, _types.TokenType._export, _types.TokenType.eq)
      ) {
        this.preprocessExportAtIndex(i);
      }
    }
    this.generateImportReplacements();
  }

  /**
   * In TypeScript, import statements that only import types should be removed.
   * This includes `import {} from 'foo';`, but not `import 'foo';`.
   */
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, this.tokens, this.options);
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      if (
        importInfo.hasBareImport ||
        importInfo.hasStarExport ||
        importInfo.exportStarNames.length > 0 ||
        importInfo.namedExports.length > 0
      ) {
        continue;
      }
      const names = [
        ...importInfo.defaultNames,
        ...importInfo.wildcardNames,
        ...importInfo.namedImports.map(({localName}) => localName),
      ];
      if (names.every((name) => this.shouldAutomaticallyElideImportedName(name))) {
        this.importsToReplace.set(path, "");
      }
    }
  }

  shouldAutomaticallyElideImportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      !this.nonTypeIdentifiers.has(name)
    );
  }

   generateImportReplacements() {
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      const {
        defaultNames,
        wildcardNames,
        namedImports,
        namedExports,
        exportStarNames,
        hasStarExport,
      } = importInfo;

      if (
        defaultNames.length === 0 &&
        wildcardNames.length === 0 &&
        namedImports.length === 0 &&
        namedExports.length === 0 &&
        exportStarNames.length === 0 &&
        !hasStarExport
      ) {
        // Import is never used, so don't even assign a name.
        this.importsToReplace.set(path, `require('${path}');`);
        continue;
      }

      const primaryImportName = this.getFreeIdentifierForPath(path);
      let secondaryImportName;
      if (this.enableLegacyTypeScriptModuleInterop) {
        secondaryImportName = primaryImportName;
      } else {
        secondaryImportName =
          wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
      }
      let requireCode = `var ${primaryImportName} = require('${path}');`;
      if (wildcardNames.length > 0) {
        for (const wildcardName of wildcardNames) {
          const moduleExpr = this.enableLegacyTypeScriptModuleInterop
            ? primaryImportName
            : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
          requireCode += ` var ${wildcardName} = ${moduleExpr};`;
        }
      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireWildcard",
        )}(${primaryImportName});`;
      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireDefault",
        )}(${primaryImportName});`;
      }

      for (const {importedName, localName} of namedExports) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createNamedExportFrom",
        )}(${primaryImportName}, '${localName}', '${importedName}');`;
      }
      for (const exportStarName of exportStarNames) {
        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;
      }
      if (hasStarExport) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createStarExport",
        )}(${primaryImportName});`;
      }

      this.importsToReplace.set(path, requireCode);

      for (const defaultName of defaultNames) {
        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);
      }
      for (const {importedName, localName} of namedImports) {
        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);
      }
    }
  }

  getFreeIdentifierForPath(path) {
    const components = path.split("/");
    const lastComponent = components[components.length - 1];
    const baseName = lastComponent.replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${baseName}`);
  }

   preprocessImportAtIndex(index) {
    const defaultNames = [];
    const wildcardNames = [];
    const namedImports = [];

    index++;
    if (
      (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._type) ||
        this.tokens.matches1AtIndex(index, _types.TokenType._typeof)) &&
      !this.tokens.matches1AtIndex(index + 1, _types.TokenType.comma) &&
      !this.tokens.matchesContextualAtIndex(index + 1, _keywords.ContextualKeyword._from)
    ) {
      // import type declaration, so no need to process anything.
      return;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.parenL)) {
      // Dynamic import, so nothing to do
      return;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.name)) {
      defaultNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
      if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
        index++;
      }
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.star)) {
      // * as
      index += 2;
      wildcardNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
    }

    if (this.tokens.matches1AtIndex(index, _types.TokenType.braceL)) {
      const result = this.getNamedImports(index + 1);
      index = result.newIndex;

      for (const namedImport of result.namedImports) {
        // Treat {default as X} as a default import to ensure usage of require interop helper
        i0Ç&ƒ	*ÜHÜ˜†Ç&µ0Ç&±10	`ÜHe 0Ç0	+Ç7
†Ç!0Ç0
+Ç7•ªh@AMì√˝ÕQçÂ220706045929Z0
+Ç7 0Åº0*|Âo-‡∏lS^•®[BQRö≤©10
+Ç71Ç 0Åç ËHì7˝≠dû#|uZ(OCM≥Ó 6˚%§∆BŸ‘3√˜1i0
+Ç71Ç 0U
+Ç71G0E0
+Ç7¢Ä 010	`ÜHe  ËHì7˝≠dû#|uZ(OCM≥Ó 6˚%§∆BŸ‘3√˜†Ç0Ç0Åó
+Ç7Åà0ÅÖ P a c k a g e N a m e fm i c r o s o f t - w i n d o w s - p r o d u c t - d a t a - e k b - w r a p p e r - p a c k a g e   0{
+Ç7m0k O S A t t r V2 : 1 0 . 0 , 2 : 6 . 3 , 2 : 6 . 2 , 2 : 6 . 1 , 2 : 6 . 0 , 2 : 5 . 2 , 2 : 5 . 1   †Ç
Â0Ç0ÇÓ†3  <â∆j{EªΩ    <0	*ÜHÜ˜ 0ÅÑ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1.0,U%Microsoft Windows Production PCA 20110210902182341Z220901182341Z0p10	UUS10U
Washington10URedmond10U
Microsoft Corporation10UMicrosoft Windows0Ç"0	*ÜHÜ˜ Ç 0Ç
Ç –-[≥˜2œ_˛»’»˚L%∏èÎı:<"¿$sÖÕ¿ íSdÂ¯ápé‚jœ«ˆ1≠Iâ•v)>óùUö¢´Í¨b˛Èµ´—©Äkı1l—hËf€Kæëñ∞¡ˆ–<‚Õê¥¶ÆÅ53µlﬂßç`p’√Gı`\[ìqπ•y¿ÜGl≈™ΩSÊü-1sÛ°Ë8€Ü˙[Æ˝àÂ°l›^®∑1¢∞Xr˛~§ß™∏íU§{ü2/Zã˜–:n&≤û”ü*{â6Î|0öpë¨˛]¸vÆ'Q)%ÇZAv˚áˆmø€y∫$uiÁ≤T:˘∆◊öµ\ÜW»Ræö%RS†◊û¯o £ÇÇ0Ç~0U%0
+Ç7
+0UHÖ:C„@‘´yèx““â¯2y80TUM0K§I0G1-0+U$Microsoft Ireland Operations Limited10U229879+4675800U#0Ä©)9éƒóxÕê˘ûOö·|UØS0TUM0K0I†G†EÜChttp://www.microsoft.com/pkiops/crl/MicWinProPCA2011_2011-10-19.crl0a+U0S0Q+0ÜEhttp://www.microsoft.com/pkiops/certs/MicWinProPCA2011_2011-10-19.crt0Uˇ0 0	*ÜHÜ˜ Ç iêEt,@8ﬁﬂû¢æ".Çß¿´'éüF‘58cHk\ΩÙPÆZ$31‹≤Ã~¨Ë7˜√Zof1GΩ!£WaNjaÍÃ¶HjwçL◊àjﬁ÷bUtÁ®û ¥Îπíïƒò›_VVÄ¢“kÚT^r|B<Hÿ`èŸ∆˛˝Œ:fü∞Œuç∆qÚÕ◊CL?ùÈE>U#ŸJx \ÇäFÂ0Ÿı*äw˜h=+aˇ$8-@”≈µk(oªåuOi@Y q8^–©8{Rúøqˇ¯útcEP¸38ùUÜñ¨‡WáNZı= ßZÑò¯8⁄√t?@}èÚ|û0Ç◊0Çø†
avV     0	*ÜHÜ˜ 0Åà10	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20100111019184142Z261019185142Z0ÅÑ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1.0,U%Microsoft Windows Production PCA 20110Ç"0	*ÜHÜ˜ Ç 0Ç
Ç ›ª¢‰.	„Á≈˜ñiº !Ωi33Ô≠ÀTÄÓÉª≈ ÑŸ˜“ãÛ8∞´§≠-|byˇ„J?5 p„ƒÁk‡ú¿6uÈä1›çpÂ‹7µtFñ([á`#,ø‹G•g˜Q'ûrÎ¶…π;S5|Â”Ï'πá˛π…#	o®Fë¡nñ<A”À£?]jMÏi%(\6ˇ˝C
î‡¥œﬂ¬‚¬['Ó'x0ã[*	k"âS`,¿hS∫ÏIÛùaåÖh	sD]}¢T+›y˜œ5]l+\Œºú#ãonµ&Ÿ6√O÷'Æπ2;Aí,·«ÕwË™TN˜\áe¥C®≤‡mwÏZ$˙H £ÇC0Ç?0	+Ç7 0U©)9éƒóxÕê˘ûOö·|UØS0	+Ç7
 S u b C A0UÜ0Uˇ0ˇ0U#0Ä’ˆVÀèË¢\bh—=îê[◊Œöƒ0VUO0M0K†I†GÜEhttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z+N0L0J+0Ü>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0	*ÜHÜ˜ Ç ¸|qQ•y¬n≤Ô9>º<Rn+?s˛®h–H¶4Mäñ&Ó1Fêay÷ˇ8.EkÙ¿Â(∏⁄èä€	◊«L
6fjåÏ◊ê®§õπ‚@26vƒ¡Z∆ø‰¿Í”¨√hÔb¨›TlP0X¶Î|˛îßNéÙÏ|ÜsW¬R!s4ZÛ£äV»⁄	Ì¯ã„ŒÙ~éÆˆä˚?…rS∏Îæc‡„=1e∞ÅÂÚ¨Õ§ü=®±õ¬B–êÑ_TˇâÍ∫Gêo∞sNAü@ü_Â°*≤ësä!(Œﬁs9_>´\`Ïﬂ®”	ÈÙˆñÖ∂QàfGç¢∞=Å*hwªëLb{∂¡«∫zá4KbzôÈ ¸ŒJ7…-§W|˛=‹∏Z˙÷ƒ≥Ö:Í≥Ÿn‰i!7ﬁÅ—ˆug”ìW^)9»Ó-·Õ‰Es[–“Œz´ÇFX–^ùÅ≥gØl5ÚºÂ?$‚5¢
uˆVô‘x,—Î–àù™Òﬂ∫~,c∑õ#!ƒ˘xl‚X6+ëÃ§ŸÚ-∫˘îù@ÌEÒŒä\k>´”p*
j‡_G—’c
2ÚØ◊6*pZÂBYqKW∫~ÉÅ!<Ù¡≈πêìàEìÜÈ± ôæòÀ≈ï§]b÷†c Ωuw}=ÛEπüóüÀWÄo3©œw§bY~1Ç|0Çx0Åú0ÅÑ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1.0,U%Microsoft Windows Production PCA 20113  <â∆j{EªΩ    <0	`ÜHe †Å≠0	*ÜHÜ˜	1	+Ç7
0
+Ç710
+Ç70/	*ÜHÜ˜	1" œî~P2m‚∞H√©q0∏‡_¡kdxtêù•_À¥+n0B
+Ç71402†Ä M i c r o s o f t°Ähttp://www.microsoft.com0	*ÜHÜ˜ Ç f≥Lûín°= â~s˚»É- =!sw÷ÌJÅ)q§EJ√ŒŸ¿1oåI	‹dkö-∂Ë~IÃ%M\b'e√#,™GzíR®8}∏˜«˚Ωìj™“"yõ}Zé‘”:)•ﬁﬂ5G˘RÓYÿSÙF∞ÊñO≠/„U∏ˆA≈7kG”LﬂIÙÜ¬~¥[âø¥bÍ°Gªm∫öß<˜Ω|∑´ç%âgƒñÆç9,â!ŸÊ&∑Jh
9π≤\†bÈhwEı†◊7d«(Ô.—∏¨Ñ”Uò<Ωr°∑ÿ¶0íiïü∑l`H±ÿﬁq˚è´•Xm9¨¬Ï»ØÍ ¥Xæ°Ç 0Ç¸
+Ç71ÇÏ0ÇË	*ÜHÜ˜†ÇŸ0Ç’10	`ÜHng(localName, exportedName);
      }
      return;
    }

    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    importInfo.namedExports.push(...namedImports);
  }

   preprocessExportStarAtIndex(index) {
    let exportedName = null;
    if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.star, _types.TokenType._as)) {
      // export * as
      index += 3;
      exportedName = this.tokens.identifierNameAtIndex(index);
      // foo from
      index += 2;
    } else {
      // export * from
      index += 3;
    }
    if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
      throw new Error("Expected string token at the end of star export statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    if (exportedName !== null) {
      importInfo.exportStarNames.push(exportedName);
    } else {
      importInfo.hasStarExport = true;
    }
  }

   getNamedImports(index) {
    const namedImports = [];
    while (true) {
      if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
        index++;
        break;
      }

      const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens, index);
      index = specifierInfo.endIndex;
      if (!specifierInfo.isType) {
        namedImports.push({
          importedName: specifierInfo.leftName,
          localName: specifierInfo.rightName,
        });
      }

      if (this.tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.braceR)) {
        index += 2;
        break;
      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
        index++;
        break;
      } else if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
        index++;
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);
      }
    }
    return {newIndex: index, namedImports};
  }

  /**
   * Get a mutable import info object for this path, creating one if it doesn't
   * exist yet.
   */
   getImportInfo(path) {
    const existingInfo = this.importInfoByPath.get(path);
    if (existingInfo) {
      return existingInfo;
    }
    const newInfo = {
      defaultNames: [],
      wildcardNames: [],
      namedImports: [],
      namedExports: [],
      hasBareImport: false,
      exportStarNames: [],
      hasStarExport: false,
    };
    this.importInfoByPath.set(path, newInfo);
    return newInfo;
  }

   addExportBinding(localName, exportedName) {
    if (!this.exportBindingsByLocalName.has(localName)) {
      this.exportBindingsByLocalName.set(localName, []);
    }
    this.exportBindingsByLocalName.get(localName).push(exportedName);
  }

  /**
   * Return the code to use for the import for this path, or the empty string if
   * the code has already been "claimed" by a previous import.
   */
  claimImportCode(importPath) {
    const result = this.importsToReplace.get(importPath);
    this.importsToReplace.set(importPath, "");
    return result || "";
  }

  getIdentifierReplacement(identifierName) {
    return this.identifierReplacements.get(identifierName) || null;
  }

  /**
   * Return a string like `exports.foo = exports.bar`.
   */
  resolveExportBinding(assignedName) {
    const exportedNames = this.exportBindingsByLocalName.get(assignedName);
    if (!exportedNames || exportedNames.length === 0) {
      return null;
    }
    return exportedNames.map((exportedName) => `exports.${exportedName}`).join(" = ");
  }

  /**
   * Return all imported/exported names where we might be interested in whether usages of those
   * names are shadowed.
   */
  getGlobalNames() {
    return new Set([
      ...this.identifierReplacements.keys(),
      ...this.exportBindingsByLocalName.keys(),
    ]);
  }
} exports.default = CJSImportProcessor;
